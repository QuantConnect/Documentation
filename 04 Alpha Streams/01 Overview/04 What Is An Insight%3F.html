<p>
Alphas create an expected return prediction called an  $[Insight,T:QuantConnect.Algorithm.Framework.Alphas.Insight] for assets in their universe. These Insight objects hold information funds need to act on your signals; for example, an Insight could signal <i>AAPL</i> to go <i>Up</i> by <i>0.2%</i> within <i>10 Minutes</i>; with <i>60%</i> confidence in the outcome.</p>
<p>
  Insights include the following pieces of information;
</p>
<ul>
<li>Symbol - Which asset are you signaling? <span style="color: red;">[Required]</span></li>
<li>Direction - Which direction are you expecting the asset to move? <span style="color: red;">[Required]</span></li>
<li>Magnitude - What is the predicted move of this asset?</li>
<li>Period - When will this insight complete?</li>
<li>Confidence - How strong is this signal?</li>
<li>Weight - How much capital should a fund allocate to, or emphasize, this signal?</li> <span style="color: red;">[Required]</span></li>
</ul>
<p>
Only the Symbol and Direction are required properties however the other properties add depth to your prediction which increases its usefulness and value in the marketplace.
</p>
<p>If you are using the Algorithm Framework your $[AlphaModel, T:QuantConnect.Algorithm.Framework.Alphas.AlphaModel] will yield Insight objects from your <b>Update()</b> method. We'll cover more about emitting insights in the next section, <a class="docs-internal-link" href="/docs/alpha-streams/creating-an-alpha">Creating An Alpha</a>. </p>
<div class="section-example-container">
<pre class="python">
class ConstantAlphaModel(AlphaModel):
        def Update(self, algorithm, data):
               insights = []
               return insights
</pre>
<pre class="csharp">public AlphaModel 
{
        IEnumerable&lt;Insight&gt; Update(QCAlgorithmFramework algorithm, Slice data) 
        {
               yield return new Insight(security.Symbol, _period, _type, .... );
        }
}</pre>
</div>
