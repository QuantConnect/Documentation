<p>One cancels the other (OCO) orders are a set of orders that when one fills, it cancels the rest of the orders in the set. An example is to set a take-profit and a stop-loss order right after you enter a position. In this example, when either the take-profit or stop-loss order fills, you cancel the other order. OCO orders usually create an upper and lower bound on the exit price of a trade. </p>

<p>When you place OCO orders, their price levels are usually relative to the fill price of an entry trade. If your entry trade is a synchronous market order, you can immediately get the fill price from the order ticket. If your entry trade doesn't execute immediately, you can get the fill price in the <a href="/docs/v2/writing-algorithms/trading-and-orders/order-events#02-Track-Order-Events"><span class="csharp">OnOrderEvents</span><span class="python">on_order_events</span></a> event handler. Once you have the entry fill price, you can calculate the price levels for the OCO orders.</p> 

<div class="section-example-container">
<pre class="csharp">// Get the fill price from the order ticket of a sync market order
_market = MarketOrder("SPY", 1);
var fillPrice = _market.AverageFillPrice;

// Get the fill price from the OnOrderEvent event handler
public override void OnOrderEvent(OrderEvent orderEvent)
{
    if (orderEvent.Status == OrderStatus.Filled && orderEvent.Ticket.OrderType == OrderType.Market)
    {
        var fillPrice = orderEvent.FillPrice;
    }
}</pre>
<pre class="python"># Get the fill price from the order ticket of a sync market order
self._market = self.market_order("SPY", 1)
fill_price = self._market.average_fill_price

# Get the fill price from the OnOrderEvent event handler
def on_order_event(self, order_event: OrderEvent) -&gt; None:
    if order_event.status == OrderStatus.FILLED and order_event.ticket.order_type == OrderType.MARKET:
        fill_price = order_event.fill_price</pre>
</div>

<p>After you have the target price levels, to implement the OCO orders, you can place active orders or track the security price to simulate the orders.</p>

<h4>Place Active Orders</h4>

<p>To place active orders for the OCO orders, use a combination of <a href="/docs/v2/writing-algorithms/trading-and-orders/order-types/limit-orders">limit orders</a> and <a href="/docs/v2/writing-algorithms/trading-and-orders/order-types/stop-limit-orders">stop limit orders</a>. Place these orders so that their price levels that are far enough apart from each other. If their price levels are too close, several of the orders can fill in a single time step. When one of the orders fills, in the <code class="csharp">OnOrderEvent</code><code class="python">on_order_event</code> event handler, <a href='/docs/v2/writing-algorithms/trading-and-orders/order-management/order-tickets#05-Cancel-Orders'>cancel</a> the other orders in the OCO order set.<br></p>

<div class="section-example-container">
<pre class="csharp">private OrderTicket _stopLoss;
private OrderTicket _takeProfit;

public override void OnOrderEvent(OrderEvent orderEvent)
{
    if (orderEvent.Status != OrderStatus.Filled) return;
    
    switch (orderEvent.Ticket.OrderType)
    {
        case OrderType.Market:
            _stopLoss = StopMarketOrder(orderEvent.Symbol, -orderEvent.FillQuantity, orderEvent.FillPrice*0.95m);
            _takeProfit = LimitOrder(orderEvent.Symbol, -orderEvent.FillQuantity, orderEvent.FillPrice*1.10m);
            return;
        case OrderType.StopMarket:
            _takeProfit?.Cancel();
            return;
        case OrderType.Limit:
            _stopLoss?.Cancel();
            return;
    }
}</pre>
<pre class="python">_stop_loss = None
_take_profit = None

def on_order_event(self, order_event: OrderEvent) -&gt; None:
    if order_event.status != OrderStatus.FILLED:
        return

    match order_event.ticket.order_type:
        case OrderType.MARKET:
            self._stop_loss = self.stop_market_order(order_event.symbol, -order_event.fill_quantity, order_event.fill_price*0.95)
            self._take_profit = self.limit_order(order_event.symbol, -order_event.fill_quantity, order_event.fill_price*1.10)
        case OrderType.STOP_MARKET:
            self._take_profit.cancel()
        case OrderType.LIMIT:
            self._stop_loss.cancel()</pre>
</div>

<h4>Simulate Orders</h4>
<p>To simulate OCO orders, track the asset price in the <code class="csharp">OnData</code><code class="python">on_data</code> method and place <a href="/docs/v2/writing-algorithms/trading-and-orders/order-types/market-orders">market</a> or <a href="/docs/v2/writing-algorithms/trading-and-orders/order-types/limit-orders">limit orders</a> when asset price reaches the take-profit or stop-loss level. The benefit of manually simulating the OCO orders is that both of the orders can't fill in the same time step.</p>

<div class="section-example-container">
<pre class="csharp">decimal _entryPrice;

public override void OnData(Slice slice)
{
    if (!Portfolio.Invested)
    {
        var ticket = MarketOrder("SPY", 1);
        _entryPrice = ticket.AverageFillPrice;
    }

    if (!slice.Bars.ContainsKey("SPY")) return;

    if (slice.Bars["SPY"].Price &gt;= _entryPrice * 1.10m)
    {
        Liquidate(symbol: "SPY", -1, tag: "take profit");
    }
    else if (slice.Bars["SPY"].Price &lt;= _entryPrice * 0.95m)
    {
        Liquidate(symbol: "SPY", -1, tag: "stop loss");
    }
}
</pre>
<pre class="python">def on_data(self, slice: Slice) -&gt; None:
    if not self.portfolio.invested:
        ticket = self.market_order("SPY", 1)
        self.entry_price = ticket.average_fill_price

    bar = slice.get("SPY")
    if bar:
        if bar.price &gt;= self.entry_price * 1.10:
            self.liquidate(symbol="SPY", -1, tag="take profit")

        elif bar.price &lt;= self.entry_price * 0.95:
            self.liquidate(symbol="SPY", -1, tag="stop loss")</pre>
</div>