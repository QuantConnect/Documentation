<p>When a <code>SecurityIdentifier</code> is serialized to a string, it looks something like <code>SPY R735QTJ8XC9X</code>. This two-part string is a base64 encoded set of data. Encoding all of the properties into a short format allows dense communication without requiring a third-party list or look-up. Most of the time, you will not need to work with these encoded strings. However, to deserialize the string into a <code>Symbol</code> object, call the <code>Symbol</code> method.</p>


<div class="section-example-container">
<pre class="csharp">var symbol = Symbol("GOOCV VP83T1ZUHROL");
symbol.ID.Market;     // =&gt; "USA"
symbol.SecurityType;  // =&gt; SecurityType.Equity
symbol.Value;         // =&gt; "GOOCV"
</pre>
<pre class="python">symbol = self.symbol("GOOCV VP83T1ZUHROL")
symbol.id.market     # =&gt; "USA"
symbol.security_type  # =&gt; SecurityType.equity
symbol.value         # =&gt; "GOOCV"</pre>
</div>

<p>The <code>Market</code> property distinguishes between tickers that have the same string value but represent different underlying assets. A prime example of this is the various market makers who have different prices for EURUSD. We store this data separately and as they have different fill prices, we treat the execution venues as different markets.</p>
