<p>When a <code>SecurityIdentifier</code> is serialized to a string, it looks something like <code>SPY R735QTJ8XC9X</code>. This two-part string is a base64 encoded set of data. Encoding all of the properties into a short format allows dense communication without requiring a third-party list or look-up. Most of the time, you will not need to work with these encoded strings. However, to deserialize the string into a <code>Symbol</code> object, call the <code  class="csharp">Symbol</code><code  class="python">symbol</code> method.</p>


<div class="section-example-container">
<pre class="csharp">// Extract the market, security type, and value from the symbol with ID "GOOCV VP83T1ZUHROL".
var symbol = Symbol("GOOCV VP83T1ZUHROL");
symbol.ID.Market;     // =&gt; "USA"
symbol.SecurityType;  // =&gt; SecurityType.Equity
symbol.Value;         // =&gt; "GOOCV"
</pre>
<pre class="python"># Extract the market, security type, and value from the symbol with ID "GOOCV VP83T1ZUHROL".
symbol = self.symbol("GOOCV VP83T1ZUHROL")
symbol.id.market      # =&gt; "USA"
symbol.security_type  # =&gt; SecurityType.EQUITY
symbol.value          # =&gt; "GOOCV"</pre>
</div>

<p>The <code class="csharp">Market</code><code class="python">market</code> property distinguishes between tickers that have the same string value but represent different underlying assets. A prime example of this is the various market makers who have different prices for EURUSD. We store this data separately and as they have different fill prices, we treat the execution venues as different markets.</p>
