<p>The following examples demonstrate some common practices on the subject of requesting data.</p>

<h4>Example 1: Add Linked Alternative Data for Universe Constituents</h4>
<p>
	Many traders select universe constituents and then allocate positions with two independent sets of logic. 
	Position sizing usually requires additional information, like alternative data factors. 
	To manage alternative data subscriptions for all the universe constituents, subscribe and unsubscribe from the data in the <code class='csharp'>OnSecuritiesChanged</code><code class='python'>on_securities_changed</code> method.
	The following example demonstrates how to do this with the <a href="https://www.quantconnect.com/datasets/kavout-composite-factor-bundle">KavoutCompositeFactorBundle</a>:
</p>
<div class="section-example-container">
	<pre class="csharp">public override void OnSecuritiesChanged(SecurityChanges changes)
{
    // Iterate securities that entered the universe.
    foreach (var security in changes.AddedSecurities)
    {
        // Subscribe to the factor data for the new security.
        // Save the alternative data symbol in the security object.
        security.AltDataSymbol = AddData&lt;KavoutCompositeFactorBundle&gt;(security.Symbol, Resolution.Daily).Symbol;
    }
    
    // Iterate securities that left the universe.
    foreach (var security in changes.RemovedSecurities)
    {
        // Unsubscribe from the altnerative data updates.
        RemoveSecurity(security.AltDataSymbol);
    }
}</pre>
	<pre class="python">def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
    # Iterate securities that entered the universe.
    for security in changes.added_securities:
        # Subscribe to the factor data for the new security.
        # Save the alternative data symbol in the security object.
        security.alt_data_symbol = self.add_data(KavoutCompositeFactorBundle, security.symbol, Resolution.DAILY).symbol
    
    # Iterate securities that left the universe.
    for security in changes.removed_securities:
        # Unsubscribe from the altnerative data updates.
        self.remove_security(security.alt_data_symbol)</pre>
</div>

<h4>Example 2: Add Linked Custom Data</h4>
<p>
	QuantConnect Cloud has a lot of data, but not everything. 
	To import some external data into your algorithm, define a <a href='/docs/v2/writing-algorithms/importing-data/streaming-data/custom-securities/key-concepts'>custom data source</a>. 
	The following example demonstrates how to request Bitstamp's BTCUSD trading activity from a CSV file:
</p>
<div class="section-example-container">
	<pre class="csharp">// Define the algorithm.
public class LinkedCustomDataExampleAlgorithm : QCAlgorithm
{
    private Crypto btc;
    public override void Initialize()
    {
        SetStartDate(2011, 9, 13);
        SetEndDate(2021, 6, 20);
        // Subscribe to Bitcoin and the custom dataset.
        btc = AddCrypto("BTCUSD");
        (btc as dynamic).dataSymbol = AddData&lt;Bitstamp&gt;(btc.Symbol.Value, Resolution.Daily).Symbol;
    }
}

// Define the custom data source.
public class Bitstamp : BaseData
{
    // Declear the properties of the custom dataset.
    public int Timestamp = 0;
    public decimal Open = 0;
    public decimal High = 0;
    public decimal Low = 0;
    public decimal Close = 0;
    public decimal Bid = 0;
    public decimal Ask = 0;
    public decimal WeightedPrice = 0;
    public decimal VolumeBTC = 0;
    public decimal VolumeUSD = 0;

    // Override the GetSource method to load the data from its location.
    public override SubscriptionDataSource GetSource(SubscriptionDataConfig config, DateTime date, bool isLiveMode)
    {
        var source = "https://raw.githubusercontent.com/QuantConnect/Documentation/master/Resources/datasets/custom-data/bitstampusd.csv";
        return new SubscriptionDataSource(source, SubscriptionTransportMedium.RemoteFile);  // RemoteFile means it's in online storage.
    }

    // Override the Reader method to read the CSV rows.
    public override BaseData Reader(SubscriptionDataConfig config, string line, DateTime date, bool isLiveMode)
    {
        // Ignore empty rows.
        if (string.IsNullOrWhiteSpace(line.Trim()))
        {
            return null;
        }
        
        // Instantiate a new data object.
        var coin = new Bitstamp() {Symbol = config.Symbol};

        // Ignore non-numeric lines.
        if (!char.IsDigit(line[0]))
        {
            return null;
        }

        // Split the CSV data by its commas.
        var data = line.Split(',');
        coin.Value = data[4].IfNotNullOrEmpty(s =&gt; decimal.Parse(s, NumberStyles.Any, CultureInfo.InvariantCulture));
        // Ignore invalid data.
        if (coin.Value == 0)
        {
            return null;
        }

        // Parse the row.
        coin.Time = DateTime.Parse(data[0], CultureInfo.InvariantCulture);
        coin.EndTime = coin.Time.AddDays(1);
        coin.Open = data[1].IfNotNullOrEmpty(s =&gt; decimal.Parse(s, NumberStyles.Any, CultureInfo.InvariantCulture));
        coin.High = data[2].IfNotNullOrEmpty(s =&gt; decimal.Parse(s, NumberStyles.Any, CultureInfo.InvariantCulture));
        coin.Low = data[3].IfNotNullOrEmpty(s =&gt; decimal.Parse(s, NumberStyles.Any, CultureInfo.InvariantCulture));
        coin.VolumeBTC = data[5].IfNotNullOrEmpty(s =&gt; decimal.Parse(s, NumberStyles.Any, CultureInfo.InvariantCulture));
        coin.VolumeUSD = data[6].IfNotNullOrEmpty(s =&gt; decimal.Parse(s, NumberStyles.Any, CultureInfo.InvariantCulture));
        coin.WeightedPrice = data[7].IfNotNullOrEmpty(s =&gt; decimal.Parse(s, NumberStyles.Any, CultureInfo.InvariantCulture));
        coin.Close = coin.Value;
        return coin;
    }
}</pre>
	<pre class="python"># Define the algorithm.
class LinkedCustomDataExampleAlgorithm(QCAlgorithm):

    def initialize(self):
        self.set_start_date(2011, 9, 13)
        self.set_end_date(2021, 6, 20)
        # Subscribe to Bitcoin and the custom dataset.
        self._btc = self.add_crypto('BTCUSD')
        self._btc.data_symbol = self.add_data(Bitstamp, self._btc.symbol.value, Resolution.DAILY).symbol

# Define the custom data source.
class Bitstamp(PythonData):
    # Override the get_source method to load the data from its location.
    def get_source(self, config, date, is_live_mode):
        source = "https://raw.githubusercontent.com/QuantConnect/Documentation/master/Resources/datasets/custom-data/bitstampusd.csv"
        return SubscriptionDataSource(source, SubscriptionTransportMedium.REMOTE_FILE)  # REMOTE_FILE means it's in online storage.
    
    # Override the reader method to read the CSV rows.
    def reader(self, config, line, date, is_live_mode):
        # Ignore empty rows.
        if not line.strip():
            return None
        
        # Instantiate a new data object.
        coin = Bitstamp()
        coin.symbol = config.symbol

        # Ignore non-numeric lines.
        if not line[0].isdigit():
            return None

        # Split the CSV data by its commas.
        data = line.split(',')

        # Ignore invalid data.
        coin.value = float(data[4])
        if coin.value == 0:
            return None

        # Parse the row.
        coin.time = datetime.strptime(data[0], "%Y-%m-%d")
        coin.end_time = coin.time + timedelta(1)
        coin["Open"] = float(data[1])
        coin["High"] = float(data[2])
        coin["Low"] = float(data[3])
        coin["Close"] = coin.value
        coin["VolumeBTC"] = float(data[5])
        coin["VolumeUSD"] = float(data[6])
        coin["WeightedPrice"] = float(data[7])
        return coin</pre>
</div>

