<p>
 The following examples demonstrate some common practices for requesting Futures universe data.
</p>
<h4>
 Example 1: Rollover
</h4>
<p>
 Future contracts expire monthly or quarterly in most cases. Hence, if we hold Future position in month or quarter end, we must consider rolling over to the mapped contract. The following algorithm shows how to buy and roll over to the next front month Future contract. We make use of the universe selection filter to select the front month contract and order the next mapped contract during the previous one expires.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class FutureExampleAlgorithm : QCAlgorithm
{
    private Symbol _future;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Seed the price with last known price to ensure the contract price data is available for the limit order.
        Settings.SeedInitialPrices = true;
        var future = AddFuture(Futures.Indices.SP500EMini, extendedMarketHours: true);
        _future = future.Symbol;
        // We only want to hold position of the front month contract.
        future.SetFilter(u =&gt; u.FrontMonth());
    }
    
    public override void OnSecuritiesChanged(SecurityChanges changes)
    {
        // Liquidate if expired (or not being the front month contract anymore) and exit universe.
        foreach (var removed in changes.RemovedSecurities)
        {
            Liquidate(removed.Symbol);
        }
        
        foreach (var added in changes.AddedSecurities)
        {
            // Make sure the newly added contract is an actual mapped tradable contract.
            if (!added.Symbol.IsCanonical())
            {
                // Roll over by ordering the same quantity.
                // Use limit order since market on open order is not supported on Future and avoid extreme quote filling.
                LimitOrder(added.Symbol, 1m, added.Price);
            }
        }
    }
}</pre>
<pre class="python">class FutureExampleAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Seed the price with last known price to ensure the contract price data is available for the limit order.
        self.settings.seed_initial_prices = True
        future = self.add_future(Futures.Indices.SP_500_E_MINI, extended_market_hours=True)
        self._future = future.symbol
        # We only want to hold position of the front month contract.
        future.set_filter(lambda u: u.front_month())
    
    def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
        # Liquidate if expired (or not being the front month contract anymore) and exit universe.
        for removed in changes.removed_securities:
            self.liquidate(removed.symbol)
        
        for added in changes.added_securities:
            # Make sure the newly added contract is an actual mapped tradable contract.
            if not added.symbol.is_canonical():
                # Roll over by ordering the same quantity.
                # Use limit order since market on open order is not supported on Future and avoid extreme quote filling.
                self.limit_order(added.symbol, 1, added.price)</pre>
</div>
<h4>Example 2: Continuous Future Indicator</h4>
<p>
 One of the major applications of <a href="/docs/v2/writing-algorithms/universes/futures#12-Continous-Contracts">Continuous Futures</a> is to obtain a smooth price series to feed into indicators. 
 This technique ensures the indicator gets the price data that is comparable to the current contract in the continuous contract series.
 This example demonstrates a <a href="/docs/v2/writing-algorithms/indicators/supported-indicators/exponential-moving-average">Exponential Moving Average</a> crossover strategy based on the continuous ES contract data.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class FutureEMACrossAlgorithm : QCAlgorithm
{
    private Future _future;
    private decimal _threshold = 0.01m;  // 1% above/below the EMA.

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        SetCash(1000000);
        // Seed the price of each asset with its last known price to 
        // avoid trading errors.
        Settings.SeedInitialPrices = true;
        // Use backward ratio normalization for the continuous contract 
        // so the indicator receives a smooth price series.
        _future = AddFuture(
            Futures.Indices.SP500EMini,
            dataNormalizationMode: DataNormalizationMode.BackwardsRatio
        );
        // Only add the front-month contract.
        _future.SetFilter(u => u.FrontMonth());
        // Create a 252-day EMA indicator as a trend estimator.
        ((dynamic)_future).ema = EMA(_future.Symbol, 252, Resolution.Daily);
        // Warm up the EMA indicator to so we can trade right away.
        WarmUpIndicator(_future.Symbol, _future.Get&lt;ExponentialMovingAverage&gt;("ema"));
    }
    
    public override void OnData(Slice slice)
    {
        // Ensure the TradeBar data is available for the Future before
        // placing trades.
        if (!slice.Bars.TryGetValue(_future.Symbol, out var bar))
        {
            return;
        }
        // Buy the mapped contract if the trend is estimated to go up 
        // (price above the EMA).
        var ema = _future.Get&lt;ExponentialMovingAverage&gt;("ema");
        if (bar.Close >= ema * (1 + _threshold))
        {
            SetHoldings(_future.Mapped, 0.1m);
        }
        // Short the mapped contract if the trend is estimated to go down
        // (price below the EMA).
        else if (bar.Close <= ema * (1 - _threshold))
        {
            SetHoldings(_future.Mapped, -0.1m);
        }
    }
    
    public override void OnSecuritiesChanged(SecurityChanges changes)
    {
        // Liquidate the contract when it is no longer the front-month
        // contract (expired).
        foreach (var contract in changes.RemovedSecurities)
        {
            Liquidate(contract.Symbol);
        }
    }
}</pre>
<pre class="python">class FutureEMACrossAlgorithm(QCAlgorithm):

    def initialize(self) -> None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(1_000_000)
        # Seed the price of each asset with its last known price to 
        # avoid trading errors.
        self.settings.seed_initial_prices = True
        # Define a threshold for the EMA crossover.
        self._threshold = 0.01  # 1% above/below the EMA.
        # Use backward ratio normalization for the continuous contract 
        # so the indicator receives a smooth price series.
        self._future = self.add_future(
            Futures.Indices.SP_500_E_MINI,
            data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
        )
        # Only add the front-month contract.
        self._future.set_filter(lambda u: u.front_month())
        # Create a 252-day EMA indicator as a trend estimator.
        self._future.ema = self.ema(self._future.symbol, 252, Resolution.DAILY)
        # Warm up the EMA indicator to so we can trade right away.
        self.warm_up_indicator(self._future.symbol, self._future.ema)
    
    def on_data(self, slice: Slice) -> None:
        # Ensure the TradeBar data is available for the Future before
        # placing trades.
        bar = slice.bars.get(self._future.symbol)
        if not bar:
            return
        # Buy the mapped contract if the trend is estimated to go up 
        # (price above the EMA).
        if bar.close >= self._future.ema.current.value * (1+self._threshold):
            self.set_holdings(self._future.mapped, 0.1)
        # Short the mapped contract if the trend is estimated to go down
        # (price below the EMA).
        elif bar.close <= self._future.ema.current.value * (1-self._threshold):
            self.set_holdings(self._future.mapped, -0.1)
    
    def on_securities_changed(self, changes: SecurityChanges) -> None:
        # Liquidate the contract when it is no longer the front-month
        # contract (expired).
        for contract in changes.removed_securities:
            self.liquidate(contract.symbol)</pre>
</div>
<h4>
 Example 3: Contango
</h4>
<p>
 In Future trading, contango refers to the far-to-expiry Future contract price is higher than the spot price due to various reasons, such as storage fee and insurance of the commodities. The following example shows a contango trading by shorting the far contract that the price is above a threshold compared to the front month contract price and buying the front month contract to earn the premium in between.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class FutureExampleAlgorithm : QCAlgorithm
{
    private Symbol _future;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Add Gold Futures.
        var future = AddFuture(Futures.Metals.Gold);
        _future = future.Symbol;
        // Limit the expiration to within 6 months, as the longer the expiration, the higher the price uncertainty.
        future.SetFilter((u) =&gt; u.Expiration(0, 183));
    }
    
    public override void OnData(Slice slice)
    {
        // Get Future chain only for the selected Future contract.
        if (!Portfolio.Invested &amp;&amp; slice.FutureChains.TryGetValue(_future, out var chain))
        {
            // It takes 2 contracts with different expiries to form a horizontal spread arbitration to earn price difference in contango.
            if (chain.Count() &lt; 2) return;
            var farContract = chain.MaxBy(x =&gt; x.Expiry);
            var nearContract = chain.MinBy(x =&gt; x.Expiry);
    
            // Check if the far contract price is 1% higher than the near one.
            // If so, short the far contract and buy the near one to earn the horizontal spread premium.
            if (farContract.BidPrice &gt;= nearContract.AskPrice * 1.01m)
            {
                MarketOrder(farContract.Symbol, -1);
                MarketOrder(nearContract.Symbol, 1);
            }
        }
    }
    
    public override void OnSecuritiesChanged(SecurityChanges changes)
    {
        // Liquidate if expired (or not being the front month contract anymore) and exit universe.
        foreach (var removed in changes.RemovedSecurities)
        {
            Liquidate();
        }
    }
}</pre>
<pre class="python">class FutureExampleAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Add Gold Futures.
        future = self.add_future(Futures.Metals.GOLD)
        self._future = future.symbol
        # Limit the expiration to within 6 months, as the longer the expiration, the higher the price uncertainty.
        future.set_filter(lambda u: u.expiration(0, 183))
    
    def on_data(self, slice: Slice) -&gt; None:
        # Get Future chain only for the selected Future contract.
        chain = slice.future_chains.get(self._future)
        if not self.portfolio.invested and chain:
            # It takes 2 contracts with different expiries to form a horizontal spread arbitration to earn price difference in contango.
            if len(list(chain)) &lt; 2:
                return
            sorted_by_expiry = sorted(chain, key=lambda x: x.expiry)
            far_contract = sorted_by_expiry[-1]
            near_contract = sorted_by_expiry[0]
    
            # Check if the far contract price is 1% higher than the near one.
            # If so, short the far contract and buy the near one to earn the horizontal spread premium.
            if far_contract.bid_price &gt;= near_contract.ask_price * 1.01:
                self.market_order(far_contract.symbol, -1)
                self.market_order(near_contract.symbol, 1)
    
    def on_securities_changed(self, changes: SecurityChanges) -&gt; None:
        # Liquidate if expired (or not being the front month contract anymore) and exit universe.
        for removed in changes.removed_securities:
            self.liquidate()</pre>
</div>
