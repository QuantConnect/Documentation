<p>
 The following examples demonstrate some common practices for handling Futures data.
</p>
<h4>
 Example 1: Rollovers
</h4>
<p>
 Spot Future is referred to as the continuous Future contract, which is usually mapped by the front month contract or the contract with the most open interest. 
    When a contract expires or is very close to expiring, traders usually rollover from the current contract to the next contract to avoid price settlement and remain invested. 
    The following algorithm demonstrates rolling over with <a href="/docs/v2/writing-algorithms/trading-and-orders/order-types/limit-orders">limit orders</a>.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class FutureExampleAlgorithm : QCAlgorithm
{
    private Future _future;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Add the E-mini Futures and set the continuous contract mapping criteria for the rollovers.
        _future = AddFuture(
            Futures.Indices.SP500EMini,
            extendedMarketHours: true,
            dataMappingMode: DataMappingMode.OpenInterest,
            dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
            contractDepthOffset: 0
        );
        _future.SetFilter(0, 182);
    }
    
    public override void OnData(Slice slice)
    {
        // Place the initial order so you can start rolling over contracts later.
        if (!Portfolio.Invested &amp;&amp; Transactions.GetOpenOrders().Count == 0)
        {
            // Buy the contract that's currently selected in the continous contract series.
            MarketOrder(_future.Mapped, 1m);
        }
    }
    
    // Track rollover events.
    public override void OnSymbolChangedEvents(SymbolChangedEvents symbolChangedEvents)
    {
        foreach (var (symbol, changedEvent) in symbolChangedEvents)
        {
            var oldSymbol = changedEvent.OldSymbol;
            var newSymbol = changedEvent.NewSymbol;
            // The quantity to roll over should be consistent.
            var quantity = Portfolio[oldSymbol].Quantity;
            // Rolling over: Liquidate the old mapped contract and switch to the newly mapped contract.
            var tag = $"Rollover: {oldSymbol} -&gt; {newSymbol}";
            Liquidate(oldSymbol, tag: tag);
            if (quantity != 0)
            {
                // Place a limit order to avoid extreme quote filling.
                var newContract = Securities[newSymbol];
                LimitOrder(
                    newSymbol, quantity, 
                    // To avoid warnings, round the target limit price to a price that respects 
                    // the minimum price variation for the Future.
                    GetLimitPrice(newContract, newContract.Price), 
                    tag: tag
                );
            }
        }
    }

    private decimal GetLimitPrice(Security security, decimal targetLimitPrice, bool roundUp = true)
    {
        var parameters = new GetMinimumPriceVariationParameters(security, targetLimitPrice);
        var pip = security.PriceVariationModel.GetMinimumPriceVariation(parameters);
        return ((int)(targetLimitPrice / pip) + (roundUp ? 1 : 0)) * pip;
    }
}</pre>
<pre class="python">class FutureExampleAlgorithm(QCAlgorithm):

    def initialize(self):
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Add the E-mini Futures and set the continuous contract mapping criteria for the rollovers.
        self._future = self.add_future(
            Futures.Indices.SP_500_E_MINI,
            extended_market_hours=True,
            data_mapping_mode=DataMappingMode.OPEN_INTEREST,
            data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
            contract_depth_offset=0
        )
        self._future.set_filter(0, 182)
    
    def on_data(self, data):
        # Place the initial order so you can start rolling over contracts later.
        if not self.portfolio.invested and not self.transactions.get_open_orders():
            # Buy the contract that's currently selected in the continous contract series.
            self.market_order(self._future.mapped, 1)
    
    # Track rollover events.
    def on_symbol_changed_events(self, symbol_changed_events):
        for symbol, changed_event in symbol_changed_events.items():
            old_symbol = changed_event.old_symbol
            new_symbol = changed_event.new_symbol
            # The quantity to roll over should be consistent.
            quantity = self.portfolio[old_symbol].quantity
            # Rolling over: Liquidate the old mapped contract and switch to the newly mapped contract.
            tag = f"Rollover: {old_symbol} -&gt; {new_symbol}"
            self.liquidate(old_symbol, tag=tag)
            if quantity:
                # Place a limit order to avoid extreme quote filling.
                new_contract = self.securities[new_symbol]
                self.limit_order(
                    new_symbol, quantity, 
                    # To avoid warnings, round the target limit price to a price that respects 
                    # the minimum price variation for the Future.
                    self._get_limit_price(new_contract, new_contract.price), 
                    tag=tag
                )
    
    def _get_limit_price(self, security, target_limit_price, round_up=True):
        parameters = GetMinimumPriceVariationParameters(security, target_limit_price)
        pip = security.price_variation_model.get_minimum_price_variation(parameters)
        return (int(target_limit_price / pip) + int(round_up)) * pip</pre>
</div>

<h4>Example 2: Micro Gold vs Gold</h4>
<p>
 The following example demonstrates how to use the <code>SymbolPropertiesDatabase</code> to obtain the contract multipliers of both Micro Gold and Gold Future contracts. 
 The algorithm uses it to invest $500k of nominal value into each contract.
</p>
<div class="section-example-container testable">
    <pre class="csharp">public class FutureNominalBuysAlgorithm : QCAlgorithm
{
    private List&lt;Future&gt; _futures = new();

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        SetCash(1_000_000);
        // Set the continuous contract mapping criteria for both Futures 
        // since we want to trade the most liquid contracts.
        foreach (var ticker in new[] { Futures.Metals.Gold, Futures.Metals.MicroGold })
        {
            var future = AddFuture(
                ticker,
                extendedMarketHours: true,
                dataMappingMode: DataMappingMode.OpenInterest,
                dataNormalizationMode: DataNormalizationMode.BackwardsRatio,
                contractDepthOffset: 0
            );
            future.SetFilter(0, 180);
            _futures.Add(future);
        }
    }

    public override void OnData(Slice slice)
    {
        // Wait until we aren't invested and we have bars for all Futures.
        if (!Portfolio.Invested && _futures.All(f => slice.Bars.ContainsKey(f.Symbol)))
        {
            foreach (var future in _futures)
            {
                // Calculate the order size for $500k. Get the quotient 
                // after dividing by the contract multiplier  since the 
                // order size must be whole number.
                var quantity = (int)Math.Floor(
                    500_000m / (future.Price * future.SymbolProperties.ContractMultiplier)
                );
                if (quantity == 0) {
                    continue;
                }
                MarketOrder(future.Mapped, quantity);
            }
        }
    }
}</pre>
    <pre class="python">class FutureNominalBuysAlgorithm(QCAlgorithm):

    def initialize(self) -> None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(1_000_000)
        # Set the continuous contract mapping criteria for both Futures 
        # since we want to trade the most liquid contracts.
        self._futures = []
        for ticker in [Futures.Metals.GOLD, Futures.Metals.MICRO_GOLD]:
            future = self.add_future(
                ticker,
                extended_market_hours=True,
                data_mapping_mode=DataMappingMode.OPEN_INTEREST,
                data_normalization_mode=DataNormalizationMode.BACKWARDS_RATIO,
                contract_depth_offset=0
            )
            future.set_filter(0, 180)
            self._futures.append(future)

    def on_data(self, slice: Slice) -> None:
        # Wait until we aren't invested and we have bars for all Futures.
        if (not self.portfolio.invested and 
            all(future.symbol in slice.bars for future in self._futures)):
            for future in self._futures:
                # Calculate the order size for $500k. Get the quotient 
                # after dividing by the contract multiplier since the 
                # order size must be whole number.
                quantity = (
                    500_000 
                    / future.price 
                    // future.symbol_properties.contract_multiplier
                )
                if not quantity:
                    continue
                self.market_order(future.mapped, quantity)</pre>
</div>
