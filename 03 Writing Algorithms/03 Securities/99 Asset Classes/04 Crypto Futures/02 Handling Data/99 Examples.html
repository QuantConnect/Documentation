<p>The following examples demonstrate some common practices for handling Crypto Futures data.</p>

<h4>Example 1: Margin Cost Reinvest</h4>
<p>This example demonstrates how to reinvest the amount of margin cost of the Crypto Future. We short BTCUSDT Crypto Futures in the beginning. When a margin deduction event happened, the Crypto Future's base currency face amount would deducted, which is "BTC" in this example involving "BTCUSDT". In order to keep the amount of "BTC" invested stable, we can reinvest the same amount to buy back the "BTC" position.</p>
<div class="section-example-container">
    <pre class="csharp">private Symbol _symbol;
// A day comparing variable to ensure only handle margin once a day
private int _day = -1;

public override void Initialize()
{
    // Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior
    SetBrokerageModel(BrokerageName.Binance, AccountType.Margin);
    // In Binance brokerage, USD is not a valid currency to trade or automatically convertable
    // Thus, we need to set account currency as USDT and add the starting cash
    SetAccountCurrency("USDT", 1000000);
    // Add subscription of BTC-USD Futures with specific market to ensure the correct securities are selected
    var btcusdt = AddCryptoFuture("BTCUSDT", market: Market.Binance);
    _symbol = btcusdt.Symbol;
    // To short BTCUSDT, we need to hold sufficient base currency (BTC) of the pair
    btcusdt.BaseCurrency.SetAmount(10m);
}

public override void OnData(Slice slice)
{
    // Make sure to place order when market is open since market on open order is not accepted
    if (!Portfolio.Invested && IsMarketOpen(_symbol))
    {
        MarketOrder(_symbol, -10);
    }

    // Margin cost deduction is handled in MarginInterestRates, make sure handled on daily basis only
    if (slice.MarginInterestRates.ContainsKey(_symbol) && _day != Time.Day)
    {
        // Calculate the margin paid using the margin interest and holding cost
        // The interest rate on annual basis, so it needs to be divided by 365 to get daily rate
        var interestRate = slice.MarginInterestRates[_symbol].InterestRate;
        var marginPaid = Portfolio[_symbol].AbsoluteHoldingsCost * interestRate / 365m;
        // Invest the same size as the margin paid to maintain the same level of the quote currency
        MarketOrder(_symbol, -marginPaid);

        // Plot the cashbook to ensure the quote currency level is maintained
        var usdt = (Securities[_symbol] as CryptoFuture).QuoteCurrency.Amount;
        var btc = (Securities[_symbol] as CryptoFuture).BaseCurrency.Amount;
        Plot("CashBook", "USDT", usdt);
        Plot("CashBook", "BTC", btc);

        _day = Time.Day;
    }
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior
    self.set_brokerage_model(BrokerageName.BINANCE, AccountType.MARGIN)
    # In Binance brokerage, USD is not a valid currency to trade or automatically convertable
    # Thus, we need to set account currency as USDT and add the starting cash
    self.set_account_currency("USDT", 1000000)
    # Add subscriptions to BTCUSDT Future with specific market to ensure the correct securities are selected
    btcusdt = self.add_crypto_future("BTCUSDT", market=Market.BINANCE)
    self._symbol = btcusdt.symbol
    # To short BTCUSDT, we need to hold sufficient base currency (BTC) of the pair
    btcusdt.base_currency.set_amount(10)

    # A day comparing variable to ensure only handle margin once a day
    self._day = -1

def on_data(self, slice: Slice) -&gt; None:
    # Make sure to place order when market is open since market on open order is not accepted
    if not self.portfolio.invested and self.is_market_open(self._symbol):
        self.market_order(self._symbol, -10)
    
    # Margin cost deduction is handled in margin_interest_rates, make sure handled on daily basis only
    if self._symbol in slice.margin_interest_rates and self._day != self.time.day:
        # Calculate the margin paid using the margin interest and holding cost
        # The interest rate on annual basis, so it needs to be divided by 365 to get daily rate
        interest_rate = slice.margin_interest_rates[self._symbol].interest_rate
        margin_paid = self.portfolio[self._symbol].absolute_holding_cost * interest_rate / 365
        # Invest the same size as the margin paid to maintain the same level of the quote currency
        self.market_order(self._symbol, -margin_paid)

        # Plot the cashbook to ensure the quote currency level is maintained
        usdt = self.securities[self._symbol].quote_currency.amount
        btc = self.securities[self._symbol].base_currency.amount
        self.plot("CashBook", "USDT", usdt)
        self.plot("CashBook", "BTC", btc)
    
        self._day = self.time.day</pre>
</div>

<h4>Example 2: Future-Spot Arbitration</h4>
<p>Long-short arbitrage involves simultaneously trading BTCUSD in the spot market and BTCUSD futures with the same size. If the spot price exceed the front-month future price by a threshold, we short the spot and buy the future, assuming their discrepancies will be wiped out within a short period due to market efficiency. Vice versa for the other way around. Positions will be closed after the price gap bounced back.</p>
<div class="section-example-container">
    <pre class="csharp">private Symbol _spot;
private Symbol _future;

public override void Initialize()
{
    // Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior
    SetBrokerageModel(BrokerageName.Binance, AccountType.Margin);
    // In Binance brokerage, USD is not a valid currency to trade or automatically convertable
    // Thus, we need to set account currency as USDT and add the starting cash
    SetAccountCurrency("USDT", 1000);
    // Add subscription of BTC-USD Futures and spot crypto with specific market to ensure the correct securities are selected
    _future = AddCryptoFuture("BTCUSDT", market: Market.Binance).Symbol;
    _spot = AddCrypto("BTCUSDT", market: Market.Binance).Symbol;
}

public override void OnData(Slice slice)
{
    // Only compare the most updated price if both spot and future are available to ensure fair comparison for arbitration
    if (slice.Bars.ContainsKey(_spot) && slice.Bars.ContainsKey(_future))
    {
        var spotPrice = slice.Bars[_spot].Price;
        var futurePrice = slice.Bars[_future].Price;

        // To provide sufficient profit margin to overcome fee and slippage, a threshold of 0.5% is set
        // Buy low sell high: if one's price is above another by the set threshold, sell it and buy the other security
        if (spotPrice &gt;= futurePrice * 1.005m)
        {
            SetHoldings(_spot, -0.25m);
            SetHoldings(_future, 0.25m);
        }
        else if (spotPrice * 1.005m &lt;= futurePrice)
        {
            SetHoldings(_spot, 0.25m);
            SetHoldings(_future, -0.25m);
        }
        // When the mispricing converges, close both positions to earn the spread
        else if ((Portfolio[_spot].Quantity &lt; 0 && spotPrice &lt; futurePrice)
            || (Portfolio[_spot].Quantity &gt; 0 && spotPrice &gt; futurePrice))
        {
            Liquidate();
        }
    }
}</pre>
    <pre class="python">def initialize(self) -&gt; None:
    # Set brokerage and account type to match your brokerage environment for accurate fee and margin behavior
    self.set_brokerage_model(BrokerageName.BINANCE, AccountType.MARGIN)
    # In Binance brokerage, USD is not a valid currency to trade or automatically convertable
    # Thus, we need to set account currency as USDT and add the starting cash
    self.set_account_currency("USDT", 1000)
    # Add subscription of BTC-USD Futures and spot crypto with specific market to ensure the correct securities are selected
    self._future = self.add_crypto_future("BTCUSDT", market=Market.BINANCE).symbol
    self._spot = self.add_crypto("BTCUSDT", market=Market.BINANCE).symbol

def on_data(self, slice: Slice) -&gt; None:
    # Only compare the most updated price if both spot and future are available to ensure fair comparison for arbitration
    if self._spot in slice.bars and self._future in slice.bars:
        spot_price = slice.bars[self._spot].price
        future_price = slice.bars[self._future].price
    
        # To provide sufficient profit margin to overcome fee and slippage, a threshold of 0.5% is set
        # Buy low sell high: if one's price is above another by the set threshold, sell it and buy the other security
        if spot_price &gt;= future_price * 1.005:
            self.set_holdings(self._spot, -0.25)
            self.set_holdings(self._future, 0.25)
        elif spot_price * 1.005 &lt;= future_price:
            self.set_holdings(self._spot, 0.25)
            self.set_holdings(self._future, -0.25)
        # When the mispricing converges, close both positions to earn the spread
        elif (self.portfolio[self._spot].quantity &lt; 0 and spot_price &lt; future_price)\
        or (self.portfolio[self._spot].quantity &gt; 0 and spot_price &gt; future_price):
            self.liquidate()</pre>
</div>