<p>
 The following examples demonstrate some common practices for handling Crypto data.
</p>
<h4>
 Example 1: Dollar Cost Average BTC
</h4>
<p>
 Dollar cost averaging (DCA) is where you consistently invest a fixed dollar amount into an asset on a regular basis (for example, monthly), regardless of the asset's price. 
	It can reduce the volatility in your PnL due to slowly increasing the position size over time. 
	The following algorithm demonstrates a DCA investment into BTC. 
	It buys $3,000 USD worth of BTC every midnight for 30 consecutive days.
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class CryptoExampleAlgorithm : QCAlgorithm
{
    private Symbol _symbol;
    // Set a day count variable for counting the days of the DCA trade.
    private int _dayCount = 0;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Set the brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        SetBrokerageModel(BrokerageName.Bitfinex, AccountType.Cash);
        // For daily DCA purchases, subscribe to daily asset data.
        _symbol = AddCrypto("BTCUSD", Resolution.Daily).Symbol;
    }

    public override void OnData(Slice slice)
    {
        // If you haven't invested for 30 consecutive days yet, continue buying.
        if (slice.Bars.ContainsKey(_symbol) &amp;&amp; _dayCount++ &lt; 30)
        {
            // Calculate the order size for $3,000 USD using the current price.
            var quantity = 3000m / slice.Bars[_symbol].Close;
            // Round down to observe the lot size.
            var lotSize = Securities[_symbol].SymbolProperties.LotSize;
            quantity = (long)(quantity / lotSize) * lotSize;
            if (quantity != 0)
            {
                MarketOrder(_symbol, quantity);
            }
        }
    }
}</pre>
<pre class="python">class CryptoExampleAlgorithm(QCAlgorithm):
	 
    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Set a day count variable for counting the days of the DCA trade.
        self._day_count = 0
        # Set the brokerage and account type to match your brokerage environment for accurate fee and margin behavior.
        self.set_brokerage_model(BrokerageName.BITFINEX, AccountType.CASH)
        # For daily DCA purchases, subscribe to daily asset data.
        self._symbol = self.add_crypto("BTCUSD", Resolution.DAILY, Market.BITFINEX).symbol

    def on_data(self, slice: Slice) -&gt; None:
        # If you haven't invested for 30 consecutive days yet, continue buying.
        if self._symbol in slice.bars and self._day_count &lt; 30:
            # Increase the day count.
            self._day_count += 1
            # Calculate the order size for $3,000 USD using the current price.
            quantity = 3_000 / slice.bars[self._symbol].close
            # Round down to observe the lot size.
            lot_size = self.securities[self._symbol].symbol_properties.lot_size
            quantity = int(quantity / lot_size) * lot_size
            if quantity:
                self.market_order(self._symbol, quantity)</pre>
</div>
<h4>
 Example 2: Inter-Market Spread
</h4>
<p>
 There is always a small discrepancy in the price of the same Crypto pair trading on different exchanges. 
	Although you can't currently live trade on algorithm with multiple brokerages, you can study the cointegration pattern and implement 2 live nodes to capture the arbitrage opportunity. 
	The following algorithm demonstrates how to obtain the spread between the BTCUSD pair on Kraken and on Coinbase:
</p>
<div class="section-example-container testable">
 <pre class="csharp">public class CryptoExampleAlgorithm : QCAlgorithm
{
    private Symbol _krakenBtc;
    private Symbol _coinbaseBtc;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1); 
        SetEndDate(2024, 12, 31);
        // Subscribe to BTC/USD on 2 different exchanges.
        _krakenBtc = AddCrypto("BTCUSD", market: Market.Kraken).Symbol;
        _coinbaseBtc = AddCrypto("BTCUSD", market: Market.Coinbase).Symbol;
    }

    public override void OnData(Slice slice)
    {
        // Only calculate the spread if the prices on both exchanges are in the current Slice.
        if (slice.Bars.ContainsKey(_krakenBtc) &amp;&amp; slice.Bars.ContainsKey(_coinbaseBtc))
        {
            // Calculate the spread between the 2 exchanges, making sure the comparison is always in the same direction.
            var spread = slice.Bars[_krakenBtc].Close - slice.Bars[_coinbaseBtc].Close;
        }
    }
}</pre>
<pre class="python">class CryptoExampleAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Subscribe to BTC/USD on 2 different exchanges.
        self.kraken_btc = self.add_crypto("BTCUSD", market=Market.KRAKEN).symbol
        self.coinbase_btc = self.add_crypto("BTCUSD", market=Market.COINBASE).symbol

    def on_data(self, slice: Slice) -&gt; None:
        # Only calculate the spread if the prices on both exchanges are in the current Slice.
        if self.kraken_btc in slice.bars and self.coinbase_btc in slice.bars:
            # Calculate the spread between the 2 exchanges, making sure the comparison is always in the same direction.
            spread = slice.bars[self.kraken_btc].close - slice.bars[self.coinbase_btc].close</pre>
</div>
