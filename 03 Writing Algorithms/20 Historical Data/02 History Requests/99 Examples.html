<p>The following examples demonstrate some common practices for trading using historical requests.</p>

<h4>Example 1: Mean-Variance Portfolio</h4>
<p>The following algorithm constructs a monthly rebalance mean-variance portfolio using the top 20 liquid equities. The position sizing can be optimized by 1-year historical daily return of the universe members.</p>
<div class="section-example-container testable">
    <pre class="csharp">public class HistoricalRequestAlgorithm : QCAlgorithm
{
    private Universe _universe;
    
    // Instantiate the optimizer to perform mean-variance optimization.
    // Mean-variance optimization will not consider a risk-free rate, so we use 0.
    private readonly MaximumSharpeRatioPortfolioOptimizer _optimizer = new (0, 1, 0);

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        
        // Seed the last price to set the initial price.
        Settings.SeedInitialPrices = true;
        
        // Monthly renewal of the top 20 liquid universe to trade popular stocks.
        UniverseSettings.Schedule.On(DateRules.MonthStart());
        _universe = AddUniverse(Universe.Top(20));

        // Set a scheduled event to rebalance the portfolio at the start of every month.
        Schedule.On(DateRules.MonthStart(), TimeRules.At(9, 31), Rebalance);
    }

    private void Rebalance()
    {
        // Historical data request to get 1-year data for optimization.
        var symbols = _universe.Selected.ToList();
        var history = History&lt;TradeBar&gt;(symbols, 253, Resolution.Daily)
            .Where(x =&gt; symbols.All(y =&gt; x.ContainsKey(y)) &amp;&amp; x.All(y =&gt; y.Value.Close &gt; 0m))
            .ToList();
        // Daily return on the universe members to calculate the optimized weights.
        var returns = GetReturns(history, symbols);

        // Calculate the optimized weights.
        var weights = _optimizer.Optimize(returns);

        // Rebalance the portfolio according to the optimized weights (greater than 1%)
        var targets = Enumerable.Range(0, weights.Length)
            .Select(i =&gt; 
            {   
                var weight = Math.Abs(weights[i]) &gt; 0.01 ? Convert.ToDecimal(weights[i]) : 0m;
                return new PortfolioTarget(symbols[i], weight);
            })
            .ToList();
        SetHoldings(targets, liquidateExistingHoldings: true);
    }

    private static double[,] GetReturns(List&lt;DataDictionary&lt;TradeBar&gt;&gt; history, List&lt;Symbol&gt; symbols)
    {
        // Create a 2d array of historical daily returns from historical price data.
        var returns = new double[history.Count, symbols.Count];
        for (int j = 0; j &lt; symbols.Count; j++)
        {
            var lastPrice = 0.0;
            for (int i = 0; i &lt; history.Count; i++)
            {
                var current = (double) history[i][symbols[j]].Close;
                if (i &gt; 0)
                {
                    returns[i, j] = (current / lastPrice) - 1;
                }
                lastPrice = current;
            }
        }
        return returns;
    }
}</pre>
    <pre class="python">from Portfolio.MaximumSharpeRatioPortfolioOptimizer import MaximumSharpeRatioPortfolioOptimizer

class HistoricalRequestAlgorithm(QCAlgorithm):
    # Instantiate the optimizer to perform mean-variance optimization.
    # Mean-variance optimization will not consider a risk-free rate, so we use 0.
    _optimizer = MaximumSharpeRatioPortfolioOptimizer(0.0, 1.0, 0.0)

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        
        # Seed the last price to set the initial price of the BTCUSDT holdings.
        self.settings.seed_initial_prices = True

        # Monthly renewal of the top 20 liquid universe to trade popular stocks.
        self.universe_settings.schedule.on(self.date_rules.month_start())
        self._universe = self.add_universe(self.universe.top(20))

        # Set a scheduled event to rebalance the portfolio at the start of every month.
        self.schedule.on(self.date_rules.month_start(), self.time_rules.at(9, 31), self.rebalance)

    def rebalance(self) -&gt; None:
        # Historical data request to get 1-year data for optimization.
        symbols = self._universe.selected
        history = self.history(symbols, 253, Resolution.DAILY).close.unstack(0).dropna()
        # Daily return on the universe members to calculate the optimized weights.
        returns = history.pct_change().dropna()

        # Calculate the optimized weights.
        weights = self._optimizer.optimize(returns)

        # Rebalance the portfolio according to the optimized weights.
        targets = [PortfolioTarget(symbol, size if abs(size) &gt; 0.01 else 0) for symbol, size in zip(symbols, weights)]
        self.set_holdings(targets, liquidate_existing_holdings=True)</pre>
</div>

<h4>Other Examples</h4>
<p>For more examples, see the following algorithms:</p>

<div class="example-fieldset">
    <div class="example-legend">Demonstration Algorithm</div>
    
    <a class="python example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.Python/HistoryAlgorithm.py" target="_BLANK">
        HistoryAlgorithm.py  <span class="badge-python pull-right">Python</span>
    </a>
    <a class="csharp example-algorithm-link" href="https://github.com/QuantConnect/Lean/blob/master/Algorithm.CSharp/HistoryAlgorithm.cs" target="_BLANK">
        HistoryAlgorithm.cs  <span class="badge badge-sm badge-csharp pull-right">C#</span>
    </a>
</div>
