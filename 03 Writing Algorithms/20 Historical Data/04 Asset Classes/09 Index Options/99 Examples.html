<p>The following examples demonstrate some common practices for trading Index Options with historical data.</p>

<h4>Example 1: Standard-Weekly Contracts Cointegration</h4>
<p>The following example analyzes the cointegration relationship between the front-month ATM SPX and SPXW calls. By measuring their spread divergence, we trade mean reversal on their spread convergence.</p>
<div class="section-example-container testable">
    <pre class="csharp">using MathNet.Numerics.LinearRegression;

public class IndexOptionHistoricalDataAlgorithm : QCAlgorithm
{
    private Symbol _spxContract, _spxwContract;
    private decimal[] _cointegrationVector = new[] { 0m, 0m };
    private decimal _threshold = 2m;
    private decimal _spreadMean = 0m;
    private decimal _spreadSd = 1m;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        SetCash(10000000);

        // Select the Index Options to analyze and trade by week.
        Schedule.On(
            DateRules.WeekStart(),
            TimeRules.At(9, 15),
            SelectContract
        );
    }

    public override void OnData(Slice slice)
    {
        if (_spxwContract != null &amp;&amp; slice.QuoteBars.TryGetValue(_spxwContract, out var y) &amp;&amp; slice.QuoteBars.TryGetValue(_spxContract, out var x1))
        {
            // Obtain the current spread to see if there is any price divergence to trade.
            var spread = CalculateSpread(y.Close, x1.Close, _cointegrationVector);
            var z = (spread - _spreadMean) / _spreadSd;

            // If the spread diverges above or below the threshold, trade to bet on mean reversal.
            if (z &gt; _threshold &amp;&amp; !Portfolio[_spxContract].IsLong)
            {
                MarketOrder(_spxContract, 10 * _cointegrationVector[1]);
                MarketOrder(_spxwContract, -10);
            }
            else if (z &lt; -_threshold &amp;&amp; !Portfolio[_spxwContract].IsLong)
            {
                MarketOrder(_spxContract, -10 * _cointegrationVector[1]);
                MarketOrder(_spxwContract, 10);
            }
            
            // If prices converge, exit positions.
            if ((Portfolio[_spxContract].IsLong &amp;&amp; z &lt; 0m) || (Portfolio[_spxwContract].IsLong &amp;&amp; z &gt; 0m))
            {
                Liquidate();
            }
        }
    }

    private void SelectContract()
    {
        var index = QuantConnect.Symbol.Create("SPX", SecurityType.Index, Market.USA);
        // Obtain the SPX ATM call contract since it is the most liquid with which to trade.
        var spx = QuantConnect.Symbol.CreateCanonicalOption(index);
        var spxContracts = OptionChain(spx).Where(x =&gt; x.Expiry &lt;= Time.AddDays(30)).ToList();
        if (spxContracts.Count == 0)
        {
            _spxContract = null;
            _spxwContract = null;
            return;
        }
        var expiry = spxContracts.Max(x =&gt; x.Expiry);
        _spxContract = spxContracts.Where(x =&gt; x.Expiry == expiry &amp;&amp; x.Right == OptionRight.Call)
            .OrderBy(x =&gt; Math.Abs(x.Strike - x.UnderlyingLastPrice))
            .First().Symbol;
        // Obtain the SPXW contract with the same strike, right, and expiry.
        var spxw = QuantConnect.Symbol.CreateCanonicalOption(index, "SPXW", Market.USA, "?SPXW");
        _spxwContract = OptionChain(spxw).Where(x =&gt; x.Expiry == expiry &amp;&amp; x.Right == OptionRight.Call &amp;&amp; x.Strike == _spxContract.ID.StrikePrice).FirstOrDefault()?.Symbol;

        if (_spxwContract != null)
        {
            // Subscribe to the contracts we will trade
            AddIndexOptionContract(_spxContract);
            AddIndexOptionContract(_spxwContract);
            // Obtain the historical data and find their cointegration relationship.
            var history = History&lt;QuoteBar&gt;(new[] { _spxContract, _spxwContract }, 1000, Resolution.Minute).Where(x =&gt; x.ContainsKey(_spxContract) &amp;&amp; x.ContainsKey(_spxwContract)).ToList();
            _cointegrationVector = CalculateCointegrationVector(history);
            // Obtain the mean and SD of the spread between the options.
            var residual = history.Select(x =&gt; CalculateSpread(x[_spxwContract].Close, x[_spxContract].Close, _cointegrationVector)).ToList();
            _spreadMean = residual.Average();
            _spreadSd = Convert.ToDecimal(Math.Sqrt(residual.Sum(x =&gt; Math.Pow((double)(x - _spreadMean), 2) / residual.Count)));
        }
    }
    
    private decimal[] CalculateCointegrationVector(IEnumerable&lt;DataDictionary&lt;QuoteBar&gt;&gt; history)
    {
        // Use log price to eliminate the compounding effect.
        var y = history.Select(x =&gt; Math.Log((double)x[_spxwContract].Close)).ToArray();
        var x1 = history.Select(x =&gt; Math.Log((double)x[_spxContract].Close)).ToArray();

        // Create a matrix for the regression analysis.
        var n = new[] { y.Length, x1.Length }.Min();
        var designMatrix = new double[n][];
        for (int i = 0; i &lt; n; i++)
        {
            designMatrix[i] = new[] { x1[i] };
        }

        try
        {
            // Perform regression using MathNet.Numerics
            var coefficients = MultipleRegression.QR(designMatrix, y.TakeLast(n).ToArray(), intercept: true);

            // The coefficients array will contain the intercept and the coefficients for each independent variable.
            // Format: [intercept, x1]
            return new[] { (decimal)coefficients[0], (decimal)coefficients[1] };
        }
        catch
        {
            return _cointegrationVector;
        }
    }

    private decimal CalculateSpread(decimal y, decimal x1, decimal[] cointegrationVector)
    {
        // Using the cointegration vector to calculate the spread.
        return LogPrice(y) - (cointegrationVector[0] + LogPrice(x1) * cointegrationVector[1]);
    }

    private decimal LogPrice(decimal price)
    {
        return Convert.ToDecimal(Math.Log((double)price));
    }
}</pre>
    <pre class="python">from sklearn.linear_model import LinearRegression

class IndexOptionHistoricalDataAlgorithm(QCAlgorithm):
    _threshold = 2
    _cointegration_vector = [0, 0]
    _spread_mean = 0
    _spread_sd = 1
    _spx_contract = None
    _spxw_contract = None

    def initialize(self) -> None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(10000000)
        self._index = Symbol.create("SPX", SecurityType.INDEX, Market.USA)
        self._spx = Symbol.create_canonical_option(self._index)
        self._spxw = Symbol.create_canonical_option(self._index, "SPXW", Market.USA, "?SPXW")

        # Select the Index Options to analyze and trade by week.
        self.schedule.on(self.date_rules.week_start(), self.time_rules.at(9, 15), self.select_contract)

    def on_data(self, slice: Slice) -> None:
        if not (self._spx_contract and self._spxw_contract):
            return
        spxw = slice.quote_bars.get(self._spxw_contract)
        spx = slice.quote_bars.get(self._spx_contract)
        if not (spxw and spx):
            return
        # Obtain the current spread to see if there is any price divergence to trade.
        spread = self.calculate_spread(spxw.close, spx.close, self._cointegration_vector)
        z = (spread - self._spread_mean) / self._spread_sd
        # If the spread diverges above or below the threshold, trade to bet on mean reversion.
        if z > self._threshold and not self.portfolio[self._spx_contract].is_long:
            spx_qty = int(10 * self._cointegration_vector[1])
            spxw_qty = -10
            self.market_order(self._spx_contract, spx_qty)
            self.market_order(self._spxw_contract, spxw_qty)

        elif z < -self._threshold and not self.portfolio[self._spxw_contract].is_long:
            spx_qty = int(-10 * self._cointegration_vector[1])
            spxw_qty = 10
            self.market_order(self._spx_contract, spx_qty)
            self.market_order(self._spxw_contract, spxw_qty)

        # If prices converge, exit positions.
        if ((self.portfolio[self._spx_contract].is_long and z < 0) or
            (self.portfolio[self._spxw_contract].is_long and z > 0)):
            self.liquidate()

    def select_contract(self) -> None:
        self._spx_contract = None
        self._spxw_contract = None

        # Obtain the SPX ATM call contract since it is the most liquid to trade with.
        spx_contracts = [x for x in self.option_chain(self._spx) if x.expiry <= self.time + timedelta(30)]
        if not spx_contracts:
            return

        # Select the furthest expiry within the next 30 days
        expiry = max(x.expiry for x in spx_contracts)
        self._spx_contract = sorted(
            [x for x in spx_contracts 
             if x.expiry == expiry and x.right == OptionRight.CALL],
            key=lambda x: abs(x.strike - x.underlying_last_price)
        )[0].symbol

        # Obtain the SPXW contract with the same strike, right, and expiry.
        spxw_contract = next(
            (
                x for x in self.option_chain(self._spxw)
                if (x.expiry == expiry and
                    x.right == OptionRight.CALL and
                    x.strike == self._spx_contract.id.strike_price)
            ),
            None
        )
        if not spxw_contract:
            return
        self._spxw_contract = spxw_contract.symbol

        # Subscribe to the contracts we will trade
        self.add_index_option_contract(self._spx_contract)
        self.add_index_option_contract(self._spxw_contract)

        # Obtain the historical data and find their cointegration relationship.
        history = self.history(QuoteBar, [self._spx_contract, self._spxw_contract], 1000).close.droplevel([0, 1, 2]).unstack(0)

        # Run linear regression to determine cointegration relationship
        self._cointegration_vector = self.calculate_cointegration_vector(history)

        residual = self.calculate_spread(history[self._spxw_contract], history[self._spx_contract], self._cointegration_vector)

        self._spread_mean = np.mean(residual)
        self._spread_sd = np.std(residual)

    def calculate_cointegration_vector(self, history):
        # Prepare log price series
        y = np.log(history[self._spxw_contract])
        x1 = np.log(history[self._spx_contract])

        # Linear regression for cointegration
        lr = LinearRegression().fit(x1.to_frame(), y)

        return [lr.intercept_, lr.coef_[0]]

    def calculate_spread(self, y, x1, cointegration_vector):
        return np.log(y) - (cointegration_vector[0] + np.log(x1) * cointegration_vector[1])</pre>
</div>
