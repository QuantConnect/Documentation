<p>The following examples demonstrate some common practices for trading with Index historical data.</p>

<h4>Example 1: Replicating Portfolio</h4>
<p>The example below constructed a replicating SGX portfolio using the top 100 weighted SPY constituents. It provides an alternative way for retail investors to invest in SGX without access to certain financial instruments and a hedging idea on SGX close hours.</p>
<div class="section-example-container testable">
    <pre class="csharp">using MathNet.Numerics.LinearRegression;

public class SGXMatchingTradingAlgorithm : QCAlgorithm
{
    private Symbol _sgx;
    private Symbol _spy;
    private Universe _universe;
    private decimal[] _weights = null;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        SetCash(100000);
        SetWarmUp(TimeSpan.FromDays(7));
        
        // Request SGX Index data for matching.
        _sgx = AddIndex("SGX").Symbol;
        _spy = QuantConnect.Symbol.Create("SPY", SecurityType.Equity, Market.USA);
        
        // We will try to use SPY constituents to reproduce the SGX index.
        _universe = AddUniverse(Universe.ETF(_spy, UniverseSettings, constituents => 
        {
            return constituents
                .Where(x => x.Weight.HasValue)
                .OrderByDescending(x => x.Weight.Value)
                .Take(100)
                .Select(x => x.Symbol);
        }));
        
        // Schedule an event to rebalance the portfolio.
        Schedule.On(
            DateRules.EveryDay(_spy),
            TimeRules.AfterMarketOpen(_spy, 1),
            Rebalance
        );
    }

    private void Rebalance()
    {
        if (IsWarmingUp || _universe.Selected.Count == 0)
        {
            return;
        }
        
        var symbols = _universe.Selected.ToList();
        
        // Obtain the historical data.
        var allSymbols = new List&lt;Symbol&gt; { _sgx };
        allSymbols.AddRange(symbols);
        var historyRequest = History&lt;TradeBar&gt;(allSymbols, 252, Resolution.Daily).ToList();
        
        if (historyRequest.Count == 0)
        {
            return;
        }
        
        // Organize data by date.
        var dataByDate = new Dictionary&lt;DateTime, Dictionary&lt;Symbol, TradeBar&gt;&gt;();
        foreach (var slice in historyRequest)
        {
            foreach (var kvp in slice)
            {
                var symbol = kvp.Key;
                var bar = kvp.Value;
                var date = bar.Time.Date;
                
                if (!dataByDate.TryGetValue(date, out Dictionary&lt;Symbol, TradeBar&gt; value))
                {
                    value = [];
                    dataByDate[date] = value;
                }

                value[symbol] = bar;
            }
        }
        
        // Filter to dates where we have all symbols.
        var completeDates = dataByDate
            .Where(kvp =&gt; kvp.Value.ContainsKey(_sgx) &amp;&amp; symbols.All(s =&gt; kvp.Value.ContainsKey(s)))
            .OrderBy(kvp =&gt; kvp.Key)
            .Select(kvp =&gt; kvp.Value)
            .ToList();
        
        if (completeDates.Count &lt; 50)
        {
            return;
        }
        
        var benchmark = completeDates.Select(d =&gt; (double)d[_sgx].Close).ToArray();
        
        var designMatrix = new double[completeDates.Count][];
        for (int i = 0; i &lt; completeDates.Count; i++)
        {
            designMatrix[i] = [.. symbols.Select(s =&gt; (double)completeDates[i][s].Close)];
        }
        
        _weights = CalculateWeights(designMatrix, benchmark);
        
        if (_weights != null)
        {
            var targets = _weights
                .Zip(symbols, (weight, symbol) =&gt; new PortfolioTarget(symbol, weight))
                .ToList();
            SetHoldings(targets, liquidateExistingHoldings: true);
        }
    }

    private decimal[] CalculateWeights(double[][] history, double[] benchmark)
    {
        try
        {
            // Use log price to eliminate the compounding effect.
            var y = benchmark.Select(x =&gt; Math.Log(x)).ToArray();
            var designMatrix = history.Select(row =&gt; row.Select(x =&gt; Math.Log(x)).ToArray()).ToArray();
            
            // Perform regression to obtain the best-replicating portfolio of SGX.
            var coefficients = MultipleRegression.QR(designMatrix, y, intercept: false);
            
            // The coefficients array will contain the coefficients for each constituents.
            var sum = coefficients.Sum(c =&gt; Math.Abs(c));
            if (sum &gt; 0)
            {
                return [.. coefficients.Select(c =&gt; Convert.ToDecimal(c / sum))];
            }
            return _weights;
        }
        catch
        {
            return _weights;
        }
    }
}</pre>
    <pre class="python">from sklearn.linear_model import LinearRegression

class SGXMatchingTradingAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        self.set_cash(100000)
        self.set_warm_up(timedelta(7))
        
        # Request SGX Index data for matching.
        self._sgx = self.add_index("SGX").symbol
        self._spy = Symbol.create('SPY', SecurityType.EQUITY, Market.USA)
        # We will try to use SPY constituents to reproduce the SGX index.
        self._universe = self.add_universe(
            self.universe.etf(
                self._spy, 
                universe_filter_func=lambda x: [
                    y.symbol for y in sorted(
                        [y for y in x if y.weight], 
                        key=lambda x: x.weight, reverse=True
                    )[:100]
                ]
            )
        )
        
        # Schedule an event to rebalance the portfolio.
        self.schedule.on(
            self.date_rules.every_day(self._spy),
            self.time_rules.after_market_open(self._spy, 1),
            self.rebalance
        )

    def rebalance(self) -&gt; None:
        if self.is_warming_up or not self._universe.selected:
            return
        symbols = list(self._universe.selected)
        # Obtain the historical data.
        history = self.history([self._sgx] + symbols, 252, Resolution.DAILY).unstack(0).close
        history = history.groupby(history.index.date).last().dropna()
        # Obtain the weights of SPY constituents that best reproduce SGX.
        weights = self.calculate_weights(history[symbols], history[self._sgx])
        self.set_holdings(
            [PortfolioTarget(symbol, weight) for symbol, weight in zip(symbols, weights)], 
            liquidate_existing_holdings=True
        )

    def calculate_weights(self, history: pd.DataFrame, benchmark: pd.Series) -&gt; pd.Series:
        # Use log price to eliminate the compounding effect.
        # Perform regression to obtain the best-replicating portfolio of SGX.
        lr = LinearRegression(fit_intercept=False).fit(np.log(history), np.log(benchmark))
        sum_ = sum(abs(lr.coef_))
        return [c/sum_ for c in lr.coef_]</pre>
</div>
