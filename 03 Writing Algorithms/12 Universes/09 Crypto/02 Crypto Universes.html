<p>To add a universe of Cryptocurrencies, in the <code>Initialize</code> method, pass a <code>CryptoUniverse</code> to the <code>AddUniverse</code> method.</p> 

<div class="section-example-container">
    <pre class="python">def initialize(self) -&gt; None:
    self.universe_settings.asynchronous = True
    self.universe_settings.resolution = Resolution.daily
    self.set_brokerage_model(BrokerageName.COINBASE, AccountType.cash)
    
    # Add crypto universe selection
    self.universe = self.add_universe(CryptoUniverse.coinbase(lambda universe_day: [c.symbol for c in universe_day]))</pre>
    <pre class="csharp">private Universe _universe;
public override void Initialize()
{
    UniverseSettings.Asynchronous = true;
    UniverseSettings.Resolution = Resolution.Daily;
    SetBrokerageModel(BrokerageName.Coinbase, AccountType.Cash);
    
    // Add crypto universe selection
    _universe = AddUniverse(CryptoUniverse.Coinbase(universeDay =&gt; from x in universeDay select x.Symbol));
}</pre>
</div>

<p>The following table shows the helper methods to create Crypto universes for the supported exchanges:</p>
<table class="qc-table table">
    <thead>
        <tr>
            <th>Brokerage Name</th>
            <th>Helper Method</th>
            <th>Dataset page</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>BrokerageName.Binance</code></td>
	        <td><code>CryptoUniverse.Binance</code></td>
            <td><a href="/datasets/binance-crypto-price-data">Learn more</a></td>
        </tr>
        <tr>
            <td><code>BrokerageName.BinanceUS</code></td>
	        <td><code>CryptoUniverse.BinanceUS</code></td>
            <td><a href="/datasets/binance-us-crypto-price-data">Learn more</a></td>
        </tr>
        <tr>
            <td><code>BrokerageName.Bitfinex</code></td>
	        <td><code>CryptoUniverse.Bitfinex</code></td>
            <td><a href="/datasets/bitfinex-crypto-price-data">Learn more</a></td>
        </tr>
        <tr>
            <td><code>BrokerageName.Bybit</code></td>
	        <td><code>CryptoUniverse.Bybit</code></td>
            <td><a href="/datasets/bybit-crypto-price-data">Learn more</a></td>
        </tr>
        <tr>
            <td><code>BrokerageName.Coinbase</code></td>
	        <td><code>CryptoUniverse.Coinbase</code></td>
            <td><a href="/datasets/coinbase-crypto-price-data">Learn more</a></td>
        </tr>
        <tr>
            <td><code>BrokerageName.Kraken</code></td>
	        <td><code>CryptoUniverse.Kraken</code></td>
            <td><a href="/datasets/kraken-crypto-price-data">Learn more</a></td>
        </tr>
    </tbody>
</table>


<p>The following table describes the <code>CryptoUniverse</code> method arguments:</p>

<table class="qc-table table">
    <thead>
        <tr>
            <th>Argument</th>
            <th>Data Type</th>
            <th>Description</th>
            <th>Default Value</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>selector</code></td>
	        <td><code class="csharp">Func&lt;IEnumerable&lt;CryptoUniverse&gt;, IEnumerable&lt;Symbol&gt;&gt;</code><code class="python">Callable[[List[CryptoUniverse]], List[Symbol]]</code></td>
            <td>A function to select some of the Cryptocurrencies for the universe.<br></td>
            <td></td>
        </tr>
        <tr>
            <td><code>universeSettings</code></td>
	        <td><code>UniverseSettings</code></td>
            <td>The <a href="/docs/v2/writing-algorithms/universes/settings">universe settings</a>.</td>
            <td><code class="csharp">null</code><code class="python">None</code></td>
        </tr>
    </tbody>
</table>

<p>The filter function receives <code>CryptoUniverse</code> objects, which represent one of the Cryptocurrencies in the market. The <code>Symbol</code> objects that the filter function returns represent the universe constituents. <code>CryptoUniverse</code> objects have the following attributes:</p>
<div data-tree="QuantConnect.DataSource.CryptoUniverse"></div>

<p>To perform thorough filtering on the <code>CryptoUniverse</code> objects, define an isolated filter method.</p>

<div class="section-example-container">
<pre class="python">def Initialize(self) -&gt; None:
    self.UniverseSettings.Asynchronous = True
    self.UniverseSettings.Resolution = Resolution.Daily
    self.SetBrokerageModel(BrokerageName.Coinbase, AccountType.Cash)

    # Add crypto universe selection
    self.universe = self.AddUniverse(CryptoUniverse.Coinbase(self.universe_filter))<br>

def universe_filter(self, universe_day):
    # Define the universe selection function
    return [cf.Symbol for cf in universe_day if cf.Volume &gt;= 100 and cf.VolumeInUsd &gt; 10000]</pre>
<pre class="csharp">private Universe _universe;
public override void Initialize()
{
    UniverseSettings.Asynchronous = true;
    UniverseSettings.Resolution = Resolution.Daily;
    SetBrokerageModel(BrokerageName.Coinbase, AccountType.Cash);

    // Add crypto universe selection
    _universe = AddUniverse(CryptoUniverse.Coinbase(UniverseFilter));
}

private IEnumerable&lt;Symbol&gt; UniverseFilter(IEnumerable&lt; CryptoUniverse&gt; universeDay)
{
    return universeDay.Where(cf =&gt; cf.Volume &gt;= 100m &amp;&amp; cf.VolumeInUsd &gt; 10000m).Select(x =&gt; x.Symbol);
}</pre>
</div>
