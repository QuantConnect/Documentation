<p>To add a fundamental universe, in the <code>Initialize</code> method, pass a filter function to the <code>AddUniverse</code> method. The filter function receives a list of <code>Fundamental</code> objects and must return a list of <code>Symbol</code> objects. The <code>Symbol</code> objects you return from the function are the constituents of the fundamental universe and LEAN automatically creates subscriptions for them. In live mode, call the <code>Symbol.Create</code> method to swap for a CFD version of the same <code>Symbol</code>. Don't call <code>AddCfd</code> in the filter function.</p>
    
<div class="section-example-container">
    <pre class="csharp">public class MyUniverseAlgorithm : QCAlgorithm {
    private Universe _universe;
    public override void Initialize() 
    {
        UniverseSettings.Asynchronous = true;
        _universe = AddUniverse(FundamentalFilterFunction);
    }
        
    private IEnumerable&lt;Symbol&gt; FundamentalFilterFunction(IEnumerable&lt;Fundamental&gt; fundamental) 
    {
        var symbols = (from f in fundamental
                where f.HasFundamentalData
                select f.Symbol);

        if (LiveMode)
        {
            return symbols.Select(x =&gt; QuantConnect.Symbol.Create(x.Value, SecurityType.Cfd, Market.InteractiveBrokers));
        } 

        return symbols;
    }
}</pre>
    <pre class="python">class MyUniverseAlgorithm(QCAlgorithm):
    def initialize(self) -&gt; None:
        self.universe_settings.asynchronous = True
        self.universe = self.add_universe(self.fundamental_function)
    
    def fundamental_function(self, fundamental: List[Fundamental]) -&gt; List[Symbol]:
        symbols = [c.symbol for c in fundamental if c.has_fundamental_data]
        if self.live_mode:
            return [Symbol.create(x.value, SecurityType.CFD, Market.interactive_brokers) for x in symbols]
        return symbols</pre></div>

<h4>Example</h4>
<p>
The simplest example of accessing the fundamental object would be harnessing the iconic PE ratio for a stock. This is a ratio of the price it commands to the earnings of a stock. The lower the PE ratio for a stock, the more affordable it appears.
</p>
    
<div class="section-example-container">
    <pre class="csharp">// Take the top 50 by dollar volume using fundamental
// Then the top 10 by PERatio using fine
UniverseSettings.Asynchronous = true;
_universe = AddUniverse(
    fundamental =&gt;
    {
        var symbols = (from f in fundamental
            where f.Price &gt; 10 && f.HasFundamentalData && !Double.IsNaN(f.ValuationRatios.PERatio)
            orderby f.DollarVolume descending
            select f).Take(100)
            .OrderBy(f =&gt; f.ValuationRatios.PERatio).Take(10)
            .Select(f =&gt; f.Symbol);
                
        if (LiveMode)
        {
            return symbols.Select(x =&gt; QuantConnect.Symbol.Create(x.Value, SecurityType.Cfd, Market.InteractiveBrokers));
        }
        
        return symbols;
    });</pre>
    <pre class="python"># In Initialize:
self.universe_settings.asynchronous = True
self.universe = self.add_universe(self.fundamental_selection_function)
    
def fundamental_selection_function(self, fundamental: List[Fundamental]) -&gt; List[Symbol]:
    filtered = [f for f in fundamental if f.price &gt; 10 and f.has_fundamental_data and not np.isnan(f.valuation_ratios.pe_ratio)]
    sortedByDollarVolume = sorted(filtered, key=lambda f: f.dollar_volume, reverse=True)[:100]
    sortedByPeRatio = sorted(sortedByDollarVolume, key=lambda f: f.valuation_ratios.pe_ratio, reverse=False)[:10]
    symbols = [f.symbol for f in sortedByPeRatio]
    if self.live_mode:
        return [Symbol.create(x.value, SecurityType.CFD, Market.interactive_brokers) for x in symbols]
    return symbols</pre>
</div>

<h4>Practical Limitations</h4>
<p>Fundamental universes allow you to select an unlimited universe of assets to analyze. Each asset in the universe consumes approximately 5MB of RAM, so you may quickly run out of memory if your universe filter selects many assets. If you backtest your algorithms in the Algorithm Lab, familiarize yourself with the RAM capacity of your <a href='/docs/v2/cloud-platform/organizations/resources#02-Backtesting-Nodes'>backtesting</a> and <a href='/docs/v2/cloud-platform/organizations/resources#04-Live-Trading-Nodes'>live trading nodes</a>. To keep your algorithm fast and efficient, only subscribe to the assets you need.</p>