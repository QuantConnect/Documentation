<p>
The Binance Crypto Future Price dataset enables you to accurately design strategies for Cryptocurrencies with term structure. Examples include the following strategies:
</p>
<ul><li>Horizontal/Diagonal arbitrage with the underlying cryptocurrencies</li>
<li>Trade Contango/Backwardation predictions</li>
<li>Hedge for illiquid cryptocurrencies</li>
</ul>
<h4>Classic Algorithm Example</h4>
<p>The following example algorithm buys BTCUSDT perpetual future contract if the last day's close price was close to ask close price than bid close price, sells short of that in opposite, through the Binance exchange:</p>

<div class="section-example-container testable">
<pre><code class="python">from AlgorithmImports import *


class BinanceCryptoFutureDataAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Set the account currency to USDT, since you can't trade with 
        # USD and the algorithm doesn't automatically convert USD & USDT
        # holdings.
        self.set_account_currency("USDT", 100000)
        # Binance Futures Exchange accepts both Cash and Margin account 
        # types. Select the one you need for the best reality modeling.
        self.set_brokerage_model(BrokerageName.BINANCE_FUTURES, AccountType.MARGIN)
        # Add BTCUSDT data from the Binance Future exchange.
        # Perpetual futures does not have a filter function.
        self._btc = self.add_crypto_future("BTCUSDT", Resolution.DAILY)
        # Historical data
        history = self.history(self._btc, 10, Resolution.DAILY)

    def on_data(self, slice: Slice) -&gt; None:
        # Trade only based on updated price data.
        if self._btc.symbol not in slice.bars or self._btc.symbol not in slice.quote_bars:
            return
        # Scalp-trade the bid-ask spread based on the supply-demand strength
        if self._btc.price - self._btc.bid_price &gt; self._btc.ask_price - self._btc.price:
            self.set_holdings(self._btc, -0.5)
        else:
            self.set_holdings(self._btc, 1)</code></pre>
<pre><code class="csharp">public class BinanceCryptoFutureDataAlgorithm : QCAlgorithm
{
    public CryptoFuture _btc;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Set the account currency to USDT, since you can't trade with 
        // USD and the algorithm doesn't automatically convert USD & USDT
        // holdings.
        SetAccountCurrency("USDT", 100000);
        // Binance Futures Exchange accepts both Cash and Margin account 
        // types. Select the one you need for the best reality modeling.
        SetBrokerageModel(BrokerageName.BinanceFutures, AccountType.Margin);
        // Add BTCUSDT data from the Binance Future exchange.
        // Perpetual futures does not have a filter function.
        _btc = AddCryptoFuture("BTCUSDT", Resolution.Daily);
        // Historical data
        var history = History(_btc, 10, Resolution.Daily);
    }

    public override void OnData(Slice slice)
    {
        // Trade only based on updated price data.
        if (!slice.Bars.ContainsKey(_btc) || !slice.QuoteBars.ContainsKey(_btc))
        {
            return;
        }
        // Scalp-trade the bid-ask spread based on the supply-demand strength
        if (_btc.Price - _btc.BidPrice &gt; _btc.AskPrice - _btc.Price)
        {
            SetHoldings(_btc, -0.5m);
        }
        else
        {
            SetHoldings(_btc, 1m);
        }
    }
}</code></pre>
</div>
<h4>Framework Algorithm Example</h4>
<p>The following example algorithm hold a long BTCUSDT Future portfolio if the last day's close price was close to ask close price than bid close price, while hold short of that in opposite, through the Binance exchange using the <a href="/docs/v2/writing-algorithms/algorithm-framework/overview">algorithm framework</a> implementation:</p>

<div class="section-example-container testable">
<pre><code class="python">from AlgorithmImports import *


class BinanceCryptoFutureDataAlgorithm(QCAlgorithm):

    def initialize(self) -&gt; None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 12, 31)
        # Set the account currency to USDT, since you can't trade with 
        # USD and the algorithm doesn't automatically convert USD & USDT
        # holdings.
        self.set_account_currency("USDT", 100000)
        # Binance Futures Exchange accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        self.set_brokerage_model(BrokerageName.BINANCE_FUTURES, AccountType.MARGIN)
        self.universe_settings.resolution = Resolution.DAILY
        self.universe_settings.leverage = 2
        # We only trade on BTCUSDT Future in Binance Future exchange
        symbols = Symbol.create("BTCUSDT", SecurityType.CRYPTO_FUTURE, Market.BINANCE)
        self.add_universe_selection(ManualUniverseSelectionModel(symbols))
        # Custom alpha model to emit insights based on the Crypto Future price data
        self.add_alpha(CryptoFutureAlphaModel())
        # Equally invest to evenly dissipate the capital concentration risk of inidividual crypto pair
        self.set_portfolio_construction(EqualWeightingPortfolioConstructionModel())
        self.set_execution(ImmediateExecutionModel())

class CryptoFutureAlphaModel(AlphaModel):

    def __init__(self) -&gt; None:
        self.symbols = []

    def update(self, algorithm: QCAlgorithm, slice: Slice) -&gt; List[Insight]:
        insights = []

        for symbol in self.symbols:
            # Trade only based on updated price data
            if not slice.bars.contains_key(symbol) or not slice.quote_bars.contains_key(symbol):
                continue

            quote = slice.quote_bars[symbol]
            price = slice.bars[symbol].price
            
            # Scalp-trade the bid-ask spread based on the supply-demand strength
            if price - quote.bid.close &gt; quote.ask.close - price:
                direction = InsightDirection.DOWN
            else:
                direction = InsightDirection.UP
            insights.append(Insight.price(symbol, timedelta(1), direction))
            
        return insights

    def on_securities_changed(self, algorithm: QCAlgorithm, changes: SecurityChanges) -&gt; None:
        for security in changes.added_securities:
            symbol = security.symbol
            self.symbols.append(symbol)

            # Historical data
            history = algorithm.history(symbol, 10, Resolution.DAILY)

        for security in changes.removed_securities:
            symbol = security.symbol
            if symbol in self.symbols:
                self.symbols.remove(symbol)
</code></pre>
<pre><code class="csharp">public class BinanceCryptoFutureDataAlgorithm : QCAlgorithm
{
    public Symbol _symbol;

    public override void Initialize()
    {
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 12, 31);
        // Set the account currency to USDT, since you can't trade with 
        // USD and the algorithm doesn't automatically convert USD & USDT
        // holdings.
        SetAccountCurrency("USDT", 100000);
        // Binance Futures Exchange accepts both Cash and Margin account types, select the one you need for the best reality modeling.
        SetBrokerageModel(BrokerageName.BinanceFutures, AccountType.Margin);
        UniverseSettings.Resolution = Resolution.Daily;
        UniverseSettings.Leverage = 2;
        // We only trade on BTCUSDT Future in Binance Future exchange
        var symbols = new List&lt;Symbol&gt; {
            QuantConnect.Symbol.Create("BTCUSDT", SecurityType.CryptoFuture, Market.Binance)
        };
        AddUniverseSelection(new ManualUniverseSelectionModel(symbols));
        // Custom alpha model to emit insights based on the Crypto Future price data
        AddAlpha(new CryptoFutureAlphaModel());
        // Equally invest to evenly dissipate the capital concentration risk of inidividual crypto pair
        SetPortfolioConstruction(new EqualWeightingPortfolioConstructionModel());
        SetExecution(new ImmediateExecutionModel());
    }
}

public class CryptoFutureAlphaModel : AlphaModel
{
    private List&lt;Symbol&gt; _symbols = new();

    public override IEnumerable&lt;Insight&gt; Update(QCAlgorithm algorithm, Slice slice)
    {
        var insights = new List&lt;Insight&gt;();

        foreach (var symbol in _symbols)
        {
            // Trade only based on updated price data
            if (!slice.Bars.ContainsKey(symbol) || !slice.QuoteBars.TryGetValue(symbol, out var quote))
            {
                continue;
            }
            var price = slice.Bars[symbol].Price;
            
            // Scalp-trade the bid-ask spread based on the supply-demand strength
            InsightDirection direction;
            if (price - quote.Bid.Close &gt; quote.Ask.Close - price)
            {
                direction = InsightDirection.Down;
            }
            else
            {
                direction = InsightDirection.Up;
            }
            insights.Add(Insight.Price(symbol, TimeSpan.FromDays(1), direction));
        }
        return insights;
    }

    public override void OnSecuritiesChanged(QCAlgorithm algorithm, SecurityChanges changes)
    {
        foreach (var security in changes.AddedSecurities)
        {
            var symbol = security.Symbol;
            _symbols.Add(symbol);

            // Historical data
            var history = algorithm.History(symbol, 10, Resolution.Daily);
        }

        foreach (var security in changes.RemovedSecurities)
        {
            _symbols.Remove(security.Symbol);
        }
    }
}</code></pre>
</div>