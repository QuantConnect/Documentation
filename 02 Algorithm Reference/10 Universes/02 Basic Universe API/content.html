<meta name="tag" content="universes" />
<meta name="tag" content="custom universes" />
<p>
	<b>Adding Universes</b>
	<br/>
		Universes are added using the <code>AddUniverse()</code> method API. They are a type of data subscription which control what subscriptions are requested; and as such you can create <i>custom</i> universe data types. Depending on what type of universe you are adding there are many helper methods to make it easier. <code>AddUniverse()</code> methods take function filters as parameters, these filters must return an enumerable of Symbol objects.
	</p>
	<p>
		<b>Universe Settings</b>
		<br/>
			If you do not pass in a full universe object the $[UniverseSettings] property is used to fill in the blanks.  Changing the UniverseSettings algorithm property can be helpful to simplify adding universes. Universes have 4 key properties:<pre>
    //Popular universe settings:
    UniverseSettings.Resolution      // What resolution should added assets use
                    .Leverage        // What leverage should assets use in the universe?
                    .Fillforward     // Should asset data fill forward?
                    .MinimumTimeInUniverse // Minimum time assets should be in universe
                    .ExtendedMarketHours  // Should assets also feed extended market hours?
</pre>
		</p>
		<p>
			Once added universes are stored in the <code>IDictionary&lt;string, Universe&gt; UniverseManager</code>.
		</p>
		<p>
			<b>Universe Events</b>
			<br/>
				When universe contents are changed (securities are added or removed from the algorithm) we generate an <code>OnSecuritiesChanged</code> event. This allows your algorithm to know the changes in the universe state. The event passes in the $[SecurityChanges] object containing references to the Added and Removed securities.
			</p>