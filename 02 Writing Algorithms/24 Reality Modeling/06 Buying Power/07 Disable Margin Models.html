<meta name="tag" content="trading and orders" />
<meta name="tag" content="brokerage models" />
<meta name="tag" content="transaction fees fills buying power slippage" />
<meta name="tag" content="custom transaction models" />
<meta name="tag" content="order events" />
<meta name="tag" content="margin models">
<p>
Buying power models (also known as margin models) control how much buying power (leverage) your algorithm has to make trades. Buying power calculations can be very complex and depend on many factors, including the brokerage or even time of day.
</p>
<p>
	Buying power models implement the $[IBuyingPowerModel, T:QuantConnect.Securities.IBuyingPowerModel] interface and default to the $[BuyingPowerModel, T:QuantConnect.Securities.BuyingPowerModel] class. If you wish to implement your own buying power model, you can start with the default and override methods you wish to change.
</p>
<p>
	We also provide the $[PatternDayTradingMarginModel,T:QuantConnect.Securities.PatternDayTradingMarginModel] to model intraday pattern day trading for US equities, which provides 4x intraday leverage and 2x overnight leverage.
</p>
<div class="section-example-container">
	<pre class="csharp">// Example of setting a security to use PDT margin models:
// Generally you do not need to adjust margin models
Securities["AAPL"].MarginModel = new PatternDayTradingMarginModel();
</pre>
	<pre class="python"># Example of setting a security to use PDT margin models:
# Generally you do not need to adjust margin models
self.Securities["AAPL"].MarginModel =  PatternDayTradingMarginModel()
</pre>
</div>
<p>
	The margin call model can be disabled by easily setting the model to $[Null,F:QuantConnect.Securities.MarginCallModel.Null] at portfolio level.
</p>
<div class="section-example-container">
	<pre class="csharp">// In Initialize()
Portfolio.MarginCallModel = MarginCallModel.Null;
</pre>
	<pre class="python">#In Initialize()
self.Portfolio.MarginCallModel = MarginCallModel.Null
</pre>
</div>
