<span class="python">
<p>
The History method returns a multi-index DataFrame where the first index is the symbol. The data is then sorted in rows according to the second index, the <a target="_BLANK" href="/docs/key-concepts/understanding-time">EndTime</a> of the bar. By learning a few helpful short cuts, you can directly access the history values you need for your algorithm.
</p>
<div class="section-example-container">
<pre class="python"># Setup the universe:
eurusd = self.AddForex("EURUSD", Resolution.Daily).Symbol
nzdusd = self.AddForex("NZDUSD", Resolution.Daily).Symbol

# STEP 1:  Request a DataFrame:
self.df = self.History([eurusd, nzdusd], 3)
<img class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/docs/i/history-dataframe-loc-array_rev0.png">


# STEP 2: Check if the DataFrame is empty and lock onto a Symbol index with the `loc[]` method.
<br>You can access a securityâ€™s data in a DataFrame by using the Symbol or the string representation of the Symbol
if not self.df.empty:
    eurusd_quotebars = self.df.loc[eurusd] # or just "EURUSD" instead of Symbol
<img class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/docs/i/history-dataframe-loc-single_rev0.png">


# STEP 3: Extract and manipulate a single column with the string column name
spread = eurusd_quotebars["askclose"] - eurusd_quotebars["bidclose"]
<img class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/docs/i/history-dataframe-column-spread.png">
# Make sure to use the lowercase string column name.
</pre>
</div>

<p>
It's possible to also perform analysis <i>between</i> symbols by
    <a target="_BLANK" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.unstack.html">unstacking the DataFrame</a>.
Unstacking transforms each column into the Symbol values for one of the price-columns you select. 
</p>

<div class="section-example-container">
<pre class="python"># UNSTACKING: Transform into columns

# Fetch multi-indexed history:
self.dataframe = self.History([self.Symbol("IBM"), self.Symbol("AAPL")], 3)
<img class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/docs/i/history-dataframe-unstack-source_rev0.png">

# Transform using unstack:
self.dataframe["close"].unstack(level=0)
<img class="img-responsive img-thumbnail" src="https://cdn.quantconnect.com/docs/i/history-dataframe-unstack_rev1.png">
# Make sure to use the lowercase string column name.
</pre>
</div>

</span>


<span class="csharp">

<p>The History method returns an array of <code>TradeBar</code>, <code>QuoteBar</code>, or <code>Slice</code> objects, depending on how you call the method. You can iterate over these objects in a for loop to access the members of each individual <code>TradeBar</code>, <code>QuoteBar</code>, or <code>Slice</code>.</p>


<div class="section-example-container">
<pre class="csharp">// Set up the universe
var spy = AddEquity("SPY").Symbol;
var aapl = AddEquity("AAPL").Symbol;

// Example 1: Iterate over TradeBar objects
var tradeBars = History(spy, 10);
foreach (var tradeBar in tradeBars)
{
    Debug($"{tradeBar.Time}: {tradeBar.Close}");
}

// Example 2: Iterate over QuoteBar objects
var quoteBars = History(aapl, 10);
foreach (var quoteBar in quoteBars)
{
     Debug($"{s.Time}: {quoteBar.Bid.Close} / {quoteBar.Ask.Close}");
}

// Example 3: Iterate over Slice objects
var slices = History(new[] {spy, aapl}, 10);
foreach (var slice in slices)
{
    Debug($"{slice.Time}: AAPL {slice.QuoteBars[aapl].Bid.Close}, SPY {slice[spy].Close}");
}
</pre>
</div>

</span>
