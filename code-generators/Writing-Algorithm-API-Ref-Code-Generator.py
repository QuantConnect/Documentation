import os
from re import findall
from pathlib import Path
from shutil import rmtree
from _code_generation_helpers import *

CODE_GEN_TAG = f'<!-- Code generated by {os.path.basename(__file__)} -->'

def parse_description(description: str) -> str:
    
    start = description.find('<see')
    while start > 0:
        end = description.find('/>', start) + 2
        original = description[start:end]
        old = original.replace('<see cref="','')
        end = old.find('(')
        if end > 0:
            old = old[:end] + old[-4:]
        code = f"<code>{old.split('.')[-1].strip()[:-4]}</code>"
        description = description.replace(original, code)
        start = description.find('<see')

    start = description.find('<paramref')
    while start > 0:
        end = description.find('/>', start) + 2
        original = description[start:end]
        code = f"<code>{original.split('=')[-1].strip()[1:-4]}</code>"
        description = description.replace(original, code)
        start = description.find('<see')

    if description and description[-1] != '.':
        description += '.'

    return description.replace('ids', 'Id').replace('ID','Id')

def get_indicators_constructor(full_name: str) -> list:
        
    def rename_type(old):
        return 'Stochastics' if old == 'Stochastic' \
            else 'Momersion' if old == 'MomersionIndicator' \
            else old

    type_split = full_name.split('.')[1:]
    type_name = type_split[-1]
    type_split[-1] = rename_type(type_name)

    fileName = '/'.join(type_split) + ".cs"
    source = get_text_content(f'https://raw.githubusercontent.com/QuantConnect/Lean/master/{fileName}')
    lines = source.split('\n')
    constructor = []

    for l, line in enumerate(lines):
        if f"public {type_name}" not in line or '(' not in line:
            continue
        
        overload = {
            "ReturnValue": {
                "Name": type_name,
                "Type": full_name,
                "Description": f'The new <code>{type_name}</code> indicator object.',
            },
            "Parameters": [
            ],
            "DocumentationAttributes": [
                {
                    "tag": "Indicators",
                    "weight": 0,
                    "line": l + 1,
                    "fileName": f"{fileName}"
                }
            ],
            "Name": type_name,
            "FullName": full_name,
            "Tag": "T",
            "Description": ""
        }

        j = 1
        signature = line.strip()
        while '(' not in signature or ')' not in signature:
            signature += ' ' + lines[l+j].strip()
            j += 1
        signature = signature.split("(")[1].split(")")[0]
        items = signature.split(",")

        parameters = {}
        for item in items:
            arg = item.strip().split(' ')
            if not arg[0]:
                continue

            if '<' in arg[0]:
                arg = signature[signature.find(arg[0]):].split('>')
                arg[0] += '>'
                arg[1] = arg[1].strip()

            if arg[1] in parameters:
                continue

            parameters[arg[1]] = { "Type": arg[0], "Name": arg[1] }
            opt = item.split('=')
            if len(opt) > 1:
                parameters[arg[1]]["IsOptional"] = opt[1].strip()

        j = l - 1
        while "///" in lines[j]:
            if "</param>" in lines[j] and "<param name=" in lines[j]:
                param = parameters.get(lines[j].split('"')[1])
                if not param:
                    j -= 1
                    continue

                description = lines[j].split(">")[1].split("<")[0].strip()
                if not description:
                    description = "/"
                elif description[-1] != ".":
                    description += "."
                
                value = param.get("IsOptional")
                if value:
                    param["IsOptional"] = True
                    description = f"<span class='qualifier'>(Optional)</span> {description} Default: {value}"

                param["Description"] = description
                overload["Parameters"].insert(0,param)

            if "</summary>" in lines[j]:
                description = lines[j-1].split("/// ")[-1].strip()
                if description[-1] != ".":
                    description += "."
                overload["Description"] = description
            j -= 1

        constructor.append(overload)

    return constructor

def Box(input_, doc_attr, type_map, i, imax):
    if not doc_attr:
        return f"<-- Missing documentation attribute for {input_['Name']} --> "

    args = {}

    for item in input_.get('Parameters', []):
        typeId = item.get("typeId", None)
        type = type_map.get(str(typeId)) if typeId else \
            item.get('ShortType', item.get('Type'))

        description = item.get('Description', '/')
        if description[-1] not in ['.', '/']:
            description += '.'

        enum_values = item.get("EnumValues", None)
        if enum_values:
            description += '<br/><i>\n' + f'Options: {enum_values}</i>'

        if "IsOptional" in item:
            description = "(Optional) " + description
            type = "*" + type

        args[item['Name']] = { "Type": type, "Description": description }

    call = input_["Name"] + "(" + ", ".join([str(value["Type"]) + " " + str(key) for key, value in args.items()]).replace("/", "_") + ")"

    params = ""
    if args:
        params += """        <div class="parameter-list">
            <table class="parameter-table">
                <th><strong>Parameters</strong></th>"""

        for name, prop in args.items():
            description = prop["Description"]

            start = description.find("<")
            while start != -1:
                end = description.find(">", start) + 1
                substring = description[start:end]
                new_substring = ""
                start2 = substring.find('"')

                if start2 != -1:
                    new_substring = substring[start2:substring.find('"', start2 + 1)]
                    new_substring = '<code>' + new_substring.split('(')[0].split(".")[-1].split('"')[0] + '</code>'

                if "seealso" in substring:
                    new_substring = "\nSee also: " + new_substring + ".\n"

                description = description.replace(substring, new_substring)
                start = description.find("<", end)

            description = description.replace("</value>", "").replace("``1", "&lt;T&gt;")
            params += f'''                
                <tr><td><code>{prop["Type"]}</code></td>
                <td>{name}</td>
                <td>{description.replace("(Optional)", "<i>(Optional)</i>")}</td></tr>'''

        params += """
            </table>
        </div>"""

    else:
        params += "<p>This method requires no argument input.</p>"

    ret = """        <div class="method-return">
            <h4>Return</h4>\n"""
    value = input_.get("ReturnValue", None)
    if not value:
        ret += "            <p>This method provides no return.</p>\n"
    else:
        ret_, typeId = value.get("Name", None), value.get("typeId", None)
        if not ret_ and typeId:
            ret_ = type_map[str(typeId)]
        if ret_ == "Void":
            ret += f"            <p><code>{ret_}</code> - This method provides no return."
        else:
            ret += f'            <p><code>{ret_}</code>'
            description = value.get("Description", None)
            if ret_ == "Security":
                ret += f" - The new <code>Security</code> object."
            elif description:
                ret += f' - {parse_description(description)}'
            else:
                ret += f' - The new <code>{ret_}</code> object.'
        ret += '</p>\n'
    ret += "        </div>"

    fullname = input_.get("FullName", f'QuantConnect.Algorithm.QCAlgorithm.{input_["Name"]}')
    this_ = " (\n&emsp;"
    head_ = '<font color="#8F9CA3">' + ret_ + "</font> " + fullname + this_
    next_ = ",\n" + "&emsp;"

    max_ = 0
    for value in args.values():
        type_ = str(value["Type"])

        if len(type_) > max_:
            max_ = len(type_)

    call_ = head_ + \
        next_.join(["<code>" + str(value["Type"]) + "</code>" + " " * (max_ + 2 - len(str(value["Type"]))) + str(key) for key, value in args.items()]) + \
        "\n" + ")"
    call_ = call_.replace("\n", "\n" + " " * 3)

    filename, line = doc_attr[0]["fileName"], doc_attr[0]["line"]

    buttons = "\n".join([f'''<button class="method-tag" onclick="openTopTab(event, '{attr_['tag']}')">{attr_['tag']}</button>''' for attr_ in doc_attr])

    name = input_["Name"] if "Name" in input_ else input_["ShortType"]

    write_up = f"""
    <div class="method-header">
        {buttons}
        <h3>{input_["Name"]}()<span class="method-order">{i+1}/{imax}</span></h3>
        <pre>
            {call_}
        </pre>
    </div>

    <div class="method-description">
        <p>{input_.get('Description','')}</p>
    </div>

    <div class="details-btn">
        <button class="show-hide-detail" onclick="ShowHide(event, '{call.replace(" ", "-")}-details')"><span>Show Details <img src='https://cdn.quantconnect.com/i/tu/api-chevron-show.svg' alt='arrow-show'></span></button>
    </div>

    <div class="method-details" id="{call.replace(" ", "-")}-details" style="display: none;" >
 
{params}

{ret}

        <div class="method-def">
            <p>Definition at <a rel="nofollow" target="_blank" href="https://github.com/QuantConnect/Lean/blob/master/{filename}#L{line}">line {line} of file {filename}.</a></p>
        </div>        
    </div>
"""
    return write_up

if __name__ == '__main__':

    methods = {}
    methods_by_tag = {}
    type_map = {}

    doc = get_json_content('http://cdn.quantconnect.com.s3.us-east-1.amazonaws.com/terminal/cache/api/csharp_tree.json')

    for method in doc['tree']['core']['data'][0]['children']:
        if '( )' not in method['text']: continue
        for child in method["children"]:
            key = to_key(child['text'])
            if key not in methods:
                methods[key] = []
            for method in child['concentrate']:
                methods[key].append(method)

    for method in next((v for v in doc["keys"].values() if v.get("ShortType") == "QCAlgorithm")).get("Methods"):
        doc_attrs = method['DocumentationAttributes']
        if not doc_attrs:
            continue

        key = to_key(method['Name'])
        if key not in methods:
            methods[key] = []
        # Avoid duplicates
        original = True
        for overload in methods[key]:
            for doc_attr in overload['DocumentationAttributes']:
                if doc_attr in doc_attrs:
                    original = False
        if original:
            methods[key].append(method)

    for key in doc["keys"].items():
        d = '['
        s =  [s+d for s in key[1]["Type"].split(d)]
        d = ','
        s = [s_.split(",") for s_ in s]

        tmp = []
        for s_ in s:
            if len(s_) > 1:
                x_ = []
                for i_, x in enumerate(s_):
                    if i_ != len(s_) - 1:
                        x_.append(x + ",")
                    else:
                        x_.append(x)
                tmp.append(x_)
            else:
                tmp.append(s_)

        s = [item.split(".")[-1] for sublist in tmp for item in sublist]

        t_ = []
        for s_ in s:
            if "`" in s_:
                t_.append(s_.split("`")[0] + "&lt;")
            else:
                t_.append(s_.replace("[", "").replace("]", "&gt;").replace(",", ", "))

        type_map[key[0]] = "".join(t_)

    # ----------------------------------------
    # Generate Box for each QCAlgorithm Method
    # ----------------------------------------
    path = Path('Resources/qcalgorithm-api')
    path.mkdir(parents=True, exist_ok=True)

    for key, overloads in methods.items():
        imax = len(overloads)
        html = f'''<a id="{overloads[0]['Name']}-header"></a>
<div class="method-container">
        '''
        for i, overload in enumerate(overloads):
            overload['Description'] = parse_description(overload.get('Description',''))
            doc_attrs = overload.get('DocumentationAttributes')
            for doc_attr in doc_attrs:
                tag = doc_attr['tag']
                if tag not in methods_by_tag:
                    methods_by_tag[tag] = {}
                methods_by_tag[tag][key] = overloads

            html += Box(overload, doc_attrs, type_map, i, imax)

        with open(f'{path}/{key}.html', 'w', encoding='utf-8') as fp:
            fp.write(html + '</div>')

    path = Path(API_REFERENCE)
    path.mkdir(parents=True, exist_ok=True)

    # ------------------
    # Method lookup list
    # ------------------
    with open(f'{path}/01 Available QCAlgorithm Methods.php', 'w', encoding='utf-8') as fp:

        def get_rows(methods: list) -> str:
            rows = ''
            for key in sorted(methods.keys()):
                method = methods[key][0]
                name = method['Name']
                rows += f'''
<tr>
<td width="33%"><a href="#{name}-header">{name}()</a></td>
<td>{method.get('Description','')}</td>
</tr>'''
            return rows

        content = f'''{CODE_GEN_TAG}
<?php echo file_get_contents(DOCS_RESOURCES."/qcalgorithm-api/_tablinks.html"); ?>

<div class="api-ref-tag-list">
  <div style="margin-right: 0.8rem;">
    <button id="All_button" class="tablinks ref-tag-active" onclick="openTab(event, 'All')">All</button>
  </div>  
  <div>'''

        categories = sorted(methods_by_tag.keys())
        for category in categories:
            content += f'''    <button id="{category}_button" class="tablinks" onclick="openTab(event, '{category}')">{category}</button>\n'''
        content += f'''  </div>
</div>

<div id="All" class="ref-table-container" style="display: block;">
<table cellspacing="0" cellpadding="0" width="100%">
<tbody>{get_rows(methods)}
</tbody></table>
</div>'''

        for tag in categories:
            content += f'''<div id="{tag}" class="ref-table-container">
<table cellspacing="0" cellpadding="0">
<tbody>{get_rows(methods_by_tag[tag])}
</tbody></table>
</div>'''

        fp.write(content)

    # ------------------
    # Method API (boxes)
    # ------------------
    with open(f"{path}/02.php", "w", encoding="utf-8") as fp:
        content = f"""{CODE_GEN_TAG}
<?php echo file_get_contents(DOCS_RESOURCES."/qcalgorithm-api/_method_container.html"); ?>             
<hr>
<?php
""" + '\n'.join([
        f'echo file_get_contents(DOCS_RESOURCES."/qcalgorithm-api/{key}.html");'
        for key in sorted(methods.keys())
     ]) + """
?>"""
        fp.write(content)

    # -------------------------------
    # Generate Box for each Indicator
    # -------------------------------
    path = Path('Resources/indicators/constructors')
    rmtree(path, ignore_errors=True)
    path.mkdir(parents=True, exist_ok=True)

    types = set()
    for overloads in methods.values():
        for overload in overloads:
            type_name = overload['ReturnValue'].get('Type','')
            if type_name.startswith("QuantConnect.Indicators."):
                types.add(type_name)
    
    candlesticks = get_json_content("https://www.quantconnect.com/services/inspector?type=T:QuantConnect.Algorithm.CandlestickPatterns")
    for method in candlesticks['methods']:
        types.add(method['method-return-type-full-name'])

    indicators = {}
    for type_name in types:
        indicator = get_indicators_constructor(type_name)
        key = to_key(indicator[0]["ReturnValue"]["Name"])
        indicators[key] = indicator
    
    for key, overloads in indicators.items():
        imax = len(overloads)
        html = f'''<a id="{overloads[0]['Name']}-header"></a>
<div class="method-container">
        '''
        for i, overload in enumerate(overloads):
            overload['Description'] = parse_description(overload.get('Description',''))
            doc_attrs = overload.get('DocumentationAttributes')
            html += Box(overload, doc_attrs, type_map, i, imax)

        with open(f'{path}/{key}.html', 'w', encoding='utf-8') as fp:
            fp.write(html + '</div>')