import os
from typing import List, Dict
from pathlib import Path
import re
from _code_generation_helpers import *
from indicator_reference_code_generator import Generate_Indicators_Reference

CODE_GEN_TAG = f'<!-- Code generated by {os.path.basename(__file__)} -->'
EDGE_CASES = [
    "set-algorithm-mode",
    "set-deployment-target",
    "set-pandas-converter",
    "set-statistics-service"
]

def parse_description(description: str) -> str:
    
    replacements = re.findall('<see cref="(.*?)"/>|<see cref="(.*?)" />|<paramref name="(.*?)"/>|<paramref name="(.*?)" />', description)
    for code in [item for subset in replacements for item in subset if item]:
        description = description.replace(code, [x for x in code.split('.') if x][-1])
    description = description.replace('<see cref="', "<code>").replace('<paramref name="', "<code>").replace('"/>', "</code>").replace('" />', "</code>")

    if description and description[-1] != '.':
        description += '.'

    return description.replace('ids', 'Id').replace('ID','Id')

def get_indicators_constructor(full_name: str) -> list:
        
    def rename_type(old):
        return 'Stochastics' if old == 'Stochastic' \
            else 'Momersion' if old == 'MomersionIndicator' \
            else old

    type_split = full_name.split('.')[1:]
    type_name = type_split[-1]
    type_split[-1] = rename_type(type_name)

    fileName = '/'.join(type_split) + ".cs"
    source = get_text_content(f'https://raw.githubusercontent.com/QuantConnect/Lean/master/{fileName}')
    lines = source.split('\n')
    constructor = []

    for l, line in enumerate(lines):
        if f"public {type_name}" not in line or '(' not in line:
            continue
        
        overload = {
            "ReturnValue": {
                "Name": type_name,
                "Type": full_name,
                "Description": f'The new <code>{type_name}</code> indicator object.',
            },
            "Parameters": [
            ],
            "DocumentationAttributes": [
                {
                    "tag": "Indicators",
                    "weight": 0,
                    "line": l + 1,
                    "fileName": f"{fileName}"
                }
            ],
            "Name": type_name,
            "FullName": full_name,
            "Tag": "T",
            "Description": ""
        }

        j = 1
        signature = line.strip()
        while '(' not in signature or ')' not in signature:
            signature += ' ' + lines[l+j].strip()
            j += 1
        signature = signature.split("(")[1].split(")")[0]
        items = signature.split(",")

        parameters = {}
        for item in items:
            arg = item.strip().split(' ')
            if not arg[0]:
                continue

            if '<' in arg[0]:
                arg = signature[signature.find(arg[0]):].split('>')
                arg[0] += '>'
                arg[1] = arg[1].strip()

            if arg[1] in parameters:
                continue

            parameters[arg[1]] = { "Type": arg[0], "Name": arg[1] }
            opt = item.split('=')
            if len(opt) > 1:
                parameters[arg[1]]["IsOptional"] = opt[1].strip()

        j = l - 1
        while "///" in lines[j]:
            if "</param>" in lines[j] and "<param name=" in lines[j]:
                param = parameters.get(lines[j].split('"')[1])
                if not param:
                    j -= 1
                    continue

                description = lines[j].split(">")[1].split("<")[0].strip()
                if not description:
                    description = "/"
                elif description[-1] != ".":
                    description += "."
                
                value = param.get("IsOptional")
                if value:
                    param["IsOptional"] = True
                    description = f"{description} Default: {value}"

                param["Description"] = description
                overload["Parameters"].insert(0,param)

            if "</summary>" in lines[j]:
                description = lines[j-1].split("/// ")[-1].strip()
                if description[-1] != ".":
                    description += "."
                overload["Description"] = description
            j -= 1

        constructor.append(overload)

    return constructor

def convert_candlestick_method(method: Dict, source: List) -> Dict:
    
    type_name = method['method-return-type-short-name']
    l = min([i for i, elem in enumerate(source)
        if elem.count(f' {type_name}') > 1])
    
    return {
        "Name": type_name,
        "FullName": f'QuantConnect.Algorithm.CandlestickPatterns.{type_name}',
        "Tag": "M",
        "Description": parse_description(method['method-description']),
        "ReturnValue": {
            "Name": type_name,
            "Type": method['method-return-type-full-name'],
            "Description": f'The new <code>{type_name}</code> indicator object.',
        },
        "Parameters": [
            {
                'ShortType': 'Symbol',
                'Type': 'QuantConnect.Symbol',
                'Name': 'symbol',
                'Description': 'The symbol whose pattern we seek.',
                'typeId': 1
            },
            {
                'ShortType': 'Nullable`1',
                'Type': 'System.Nullable`1[QuantConnect.Resolution]',
                'Name': 'resolution',
                'Description': 'The resolution.',
                'typeId': 5,
                'IsOptional': True
            },
            {
                'ShortType': 'Func`2',
                'Type': 'System.Func`2[QuantConnect.Data.IBaseData,QuantConnect.Data.Market.TradeBar]',
                'Name': 'selector',
                'Tag': 'T',
                'Description': 'Selects a value from the BaseData to send into the indicator, if null defaults to casting the input value to a TradeBar.',
                'typeId': 7,
                'IsOptional': True
            },
        ],
        "DocumentationAttributes": [
            {
                "tag": "Indicators",
                "weight": 0,
                "line": l + 1,
                "fileName": "Algorithm/CandlestickPatterns.cs",
            }
        ]
    }

def Box(input_, doc_attr, type_map, i, imax):
    if not doc_attr:
        return f"<-- Missing documentation attribute for {input_['Name']} --> "

    args = {}

    for item in input_.get('Parameters', []):
        typeId = item.get("typeId", None)
        type = type_map.get(str(typeId)) if typeId else \
            item.get('ShortType', item.get('Type'))

        description = item.get('Description', '/')
        if description[-1] not in ['.', '/']:
            description += '.'

        enum_values = item.get("EnumValues", None)
        if enum_values:
            description += '<br/><i>\n' + f'Options: {enum_values}</i>'

        if "IsOptional" in item:
            description = "(Optional) " + description
            type = "*" + type

        args[item['Name']] = { "Type": type, "Description": description }

    call = input_["Name"] + "(" + ", ".join([str(value["Type"]) + " " + str(key) for key, value in args.items()]).replace("/", "_") + ")"

    params = ""
    if args:
        params += """        <div class="parameter-list">
            <table class="parameter-table">
                <th><strong>Parameters</strong></th>"""

        for name, prop in args.items():
            description = prop["Description"]

            start = description.find("<")
            while start != -1:
                end = description.find(">", start) + 1
                substring = description[start:end]
                new_substring = ""
                start2 = substring.find('"')

                if start2 != -1:
                    new_substring = substring[start2:substring.find('"', start2 + 1)]
                    new_substring = '<code>' + new_substring.split('(')[0].split(".")[-1].split('"')[0] + '</code>'

                if "seealso" in substring:
                    new_substring = "\nSee also: " + new_substring + ".\n"

                description = description.replace(substring, new_substring)
                start = description.find("<", end)

            description = description.replace("</value>", "").replace("``1", "&lt;T&gt;")
            params += f'''                
                <tr><td><code>{prop["Type"]}</code></td>
                <td>{name}</td>
                <td>{description.replace("(Optional)", "<span class='qualifier'>(Optional)</span>")}</td></tr>'''

        params += """
            </table>
        </div>"""

    else:
        params += "<p>This method requires no argument input.</p>"

    ret = """        <div class="method-return">
            <h4>Return</h4>\n"""
    value = input_.get("ReturnValue", None)
    if not value:
        ret += "            <p>This method provides no return.</p>\n"
    else:
        ret_, typeId = value.get("Name", None), value.get("typeId", None)
        if not ret_ and typeId:
            ret_ = type_map[str(typeId)]
        if ret_ == "Void":
            ret += f"            <p><code>{ret_}</code> - This method provides no return."
        else:
            ret += f'            <p><code>{ret_}</code>'
            description = value.get("Description", None)
            if ret_ == "Security":
                ret += f" - The new <code>Security</code> object."
            elif description:
                ret += f' - {parse_description(description)}'
            else:
                ret += f' - The new <code>{ret_}</code> object.'
        ret += '</p>\n'
    ret += "        </div>"

    fullname = input_.get("FullName", f'QuantConnect.Algorithm.QCAlgorithm.{input_["Name"]}')
    this_ = " (\n&emsp;"
    head_ = '<font color="#8F9CA3">' + ret_ + "</font> " + fullname + this_
    next_ = ",\n" + "&emsp;"

    max_ = 0
    for value in args.values():
        type_ = str(value["Type"])

        if len(type_) > max_:
            max_ = len(type_)

    call_ = head_ + \
        next_.join(["<code>" + str(value["Type"]) + "</code>" + " " * (max_ + 2 - len(str(value["Type"]))) + str(key) for key, value in args.items()]) + \
        "\n" + ")"
    call_ = call_.replace("\n", "\n" + " " * 3)

    filename, line = doc_attr[0]["fileName"], doc_attr[0]["line"]

    buttons = "\n".join([f'''<button class="method-tag" onclick="openTopTab(event, '{attr_['tag']}')">{attr_['tag']}</button>''' for attr_ in doc_attr])

    name = input_["Name"] if "Name" in input_ else input_["ShortType"]

    write_up = f"""
    <div class="method-header">
        {buttons}
        <h3>{input_["Name"]}()<span class="method-order">{i+1}/{imax}</span></h3>
        <pre>
            {call_}
        </pre>
    </div>

    <div class="method-description">
        <p>{input_.get('Description','')}</p>
    </div>

    <div class="details-btn">
        <button class="show-hide-detail" onclick="ShowHide(event, '{call.replace(" ", "-")}-details')"><span>Show Details <img src='https://cdn.quantconnect.com/i/tu/api-chevron-show.svg' alt='arrow-show'></span></button>
    </div>

    <div class="method-details" id="{call.replace(" ", "-")}-details" style="display: none;" >
 
{params}

{ret}

        <div class="method-def">
            <p>Definition at <a rel="nofollow" target="_blank" href="https://github.com/QuantConnect/Lean/blob/master/{filename}#L{line}">line {line} of file {filename}.</a></p>
        </div>        
    </div>
"""
    return write_up

def Generate_QCAlgorithm_API_Reference():
    methods = {}
    methods_by_tag = {}
    type_map = {}

    doc = get_json_content('http://cdn.quantconnect.com.s3.us-east-1.amazonaws.com/terminal/cache/api/csharp_tree.json')

    for method in doc['tree']['core']['data'][0]['children']:
        if '( )' not in method['text']: continue
        for child in method["children"]:
            key = to_key(child['text'])
            if key in EDGE_CASES: continue
            
            if key not in methods:
                methods[key] = []
            for method in child['concentrate']:
                methods[key].append(method)

    for method in next((v for v in doc["keys"].values() if v.get("ShortType") == "QCAlgorithm")).get("Methods"):
        doc_attrs = method['DocumentationAttributes']
        if not doc_attrs:
            continue

        key = to_key(method['Name'])
        if key not in methods:
            methods[key] = []
        # Avoid duplicates
        original = True
        for overload in methods[key]:
            for doc_attr in overload['DocumentationAttributes']:
                if doc_attr in doc_attrs:
                    original = False
        if original:
            methods[key].append(method)

    for key in doc["keys"].items():
        d = '['
        s =  [s+d for s in key[1]["Type"].split(d)]
        d = ','
        s = [s_.split(",") for s_ in s]

        tmp = []
        for s_ in s:
            if len(s_) > 1:
                x_ = []
                for i_, x in enumerate(s_):
                    if i_ != len(s_) - 1:
                        x_.append(x + ",")
                    else:
                        x_.append(x)
                tmp.append(x_)
            else:
                tmp.append(s_)

        s = [item.split(".")[-1] for sublist in tmp for item in sublist]

        t_ = []
        for s_ in s:
            if "`" in s_:
                t_.append(s_.split("`")[0] + "&lt;")
            else:
                t_.append(s_.replace("[", "").replace("]", "&gt;").replace(",", ", "))

        type_map[key[0]] = "".join(t_)

    # ----------------------------------------
    # Generate Box for each QCAlgorithm Method
    # ----------------------------------------
    qcapi = Path('Resources/qcalgorithm-api')
    qcapi.mkdir(parents=True, exist_ok=True)

    for key, overloads in methods.items():
        alt_key = key
        imax = len(overloads)
        html = f'''<a id="{overloads[0]['Name']}-header"></a>
<div class="method-container">
        '''
        for i, overload in enumerate(overloads):
            description = parse_description(overload.get('Description',''))
            # If the description is empty, try to use the next
            if not description:
                for j in range(i, imax):
                    description = parse_description(overloads[j].get('Description',''))
                    if description:
                        break
            overload['Description'] = description

        for i, overload in enumerate(overloads):
            overload['Description'] = parse_description(overload.get('Description',''))
            doc_attrs = overload.get('DocumentationAttributes')
            for doc_attr in doc_attrs:
                tag = doc_attr['tag']
                if tag.startswith("Indicators") and overload.get('ReturnValue', {}).get('Type'):
                    alt_key = key.replace('-','')
                if tag not in methods_by_tag:
                    methods_by_tag[tag] = {}
                methods_by_tag[tag][key] = overloads

            html += Box(overload, doc_attrs, type_map, i, imax)

        for k in set([key, alt_key]):
            with open(f'{qcapi}/{k}.html', 'w', encoding='utf-8') as fp:
                fp.write(html + '</div>')

    path = Path(API_REFERENCE)
    path.mkdir(parents=True, exist_ok=True)

    # ------------------
    # Method lookup list
    # ------------------
    with open(f'{path}/01 Available QCAlgorithm Methods.php', 'w', encoding='utf-8') as fp:

        def get_rows(methods: list) -> str:
            rows = ''
            for key in sorted(methods.keys()):
                method = methods[key][0]
                name = method['Name']
                rows += f'''
<tr>
<td width="33%"><a href="#{name}-header">{name}()</a></td>
<td>{method.get('Description','')}</td>
</tr>'''
            return rows

        content = f'''{CODE_GEN_TAG}
<?php echo file_get_contents(DOCS_RESOURCES."/qcalgorithm-api/_tablinks.html"); ?>

<div class="api-ref-tag-list">
  <div style="margin-right: 0.8rem;">
    <button id="All_button" class="tablinks ref-tag-active" onclick="openTab(event, 'All')">All</button>
  </div>  
  <div>'''

        categories = sorted(methods_by_tag.keys())
        for category in categories:
            content += f'''    <button id="{category}_button" class="tablinks" onclick="openTab(event, '{category}')">{category}</button>\n'''
        content += f'''  </div>
</div>

<div id="All" class="ref-table-container" style="display: block;">
<table cellspacing="0" cellpadding="0" width="100%">
<tbody>{get_rows(methods)}
</tbody></table>
</div>'''

        for tag in categories:
            content += f'''<div id="{tag}" class="ref-table-container">
<table cellspacing="0" cellpadding="0">
<tbody>{get_rows(methods_by_tag[tag])}
</tbody></table>
</div>'''

        fp.write(content)

    # ------------------
    # Method API (boxes)
    # ------------------
    with open(f"{path}/02.php", "w", encoding="utf-8") as fp:
        content = f"""{CODE_GEN_TAG}
<?php echo file_get_contents(DOCS_RESOURCES."/qcalgorithm-api/_method_container.html"); ?>             
<hr>
<?php
""" + '\n'.join([
        f'echo file_get_contents(DOCS_RESOURCES."/qcalgorithm-api/{key}.html");'
        for key in sorted(methods.keys())
     ]) + """
?>"""
        fp.write(content)

    # -----------------------------------------------
    # Generate Box for each Candlestick helper method
    # -----------------------------------------------
    types = set()
    source = get_text_content(f'https://raw.githubusercontent.com/QuantConnect/Lean/master/Algorithm/CandlestickPatterns.cs').split('\n')
    candlesticks = get_json_content("https://www.quantconnect.com/services/inspector?type=T:QuantConnect.Algorithm.CandlestickPatterns")
    
    for method in candlesticks['methods']:
        types.add(method['method-return-type-full-name'])
        overload = convert_candlestick_method(method, source)
        doc_attrs = overload.get('DocumentationAttributes')
        html = f'''<a id="{overload['Name']}-header"></a>
<div class="method-container">
        ''' + Box(overload, doc_attrs, type_map, 0, 1)
        
        with open(f'{qcapi}/{overload["Name"].lower()}.html', 'w', encoding='utf-8') as fp:
            fp.write(html + '</div>')

    # -------------------------------
    # Generate Box for each Indicator
    # -------------------------------
    path = Path('Resources/indicators/constructors')
    path.mkdir(parents=True, exist_ok=True)

    for overloads in methods.values():
        for overload in overloads:
            type_name = overload['ReturnValue'].get('Type','')
            if type_name.startswith("QuantConnect.Indicators."):
                types.add(type_name)
    
    indicators = {}
    for type_name in types:
        indicator = get_indicators_constructor(type_name)
        key = to_key(indicator[0]["ReturnValue"]["Name"])
        indicators[key] = indicator
    
    for key, overloads in indicators.items():
        imax = len(overloads)
        html = f'''<a id="{overloads[0]['Name']}-header"></a>
<div class="method-container">
        '''
        for i, overload in enumerate(overloads):
            overload['Description'] = parse_description(overload.get('Description',''))
            doc_attrs = overload.get('DocumentationAttributes')
            html += Box(overload, doc_attrs, type_map, i, imax)

        with open(f'{path}/{key}.html', 'w', encoding='utf-8') as fp:
            fp.write(html + '</div>')

if __name__ == '__main__':
    Generate_QCAlgorithm_API_Reference()
    Generate_Indicators_Reference()