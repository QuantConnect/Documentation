from os.path import basename
from sys import exit
from pathlib import Path
from re import findall, sub
from shutil import rmtree
from json import dumps
from _code_generation_helpers import INDICATORS, get_type, to_key, generate_landing_page

TAG = f'<!-- Code generated by {basename(__file__)} -->'
OPTION_INDICATORS = ["ImpliedVolatility", "Delta", "Gamma", "Vega", "Theta", "Rho"]
REFERENCE = "https://www.lean.io/docs/v2/lean-engine/class-reference/"
CS_REFERENCE = f"{REFERENCE}cs/classQuantConnect_1_1"
PY_REFERENCE = f"{REFERENCE}py/QuantConnect/"

def _format_introduction(type_name: str, text: str) -> str:
    if 'CandlestickPatterns' in type_name:
        return f"Create a new {text} to indicate the pattern's presence."

    text = text.replace("Represents", "This indicator represents")
    if "Source: " in text:
        link_split = text.split("http")
        return link_split[0].replace("Source: ", f'<sup><a href="https{link_split[1]}">source</a></sup>'.replace("httpss", "https"))
    return text

PROPERTIES_EXCEPTIONS = ['MovingAverageType', 'IsReady', 'WarmUpPeriod', 'Name', 'Period', 'Samples', "[System.Int32]",
                'Current', "Consolidators", "Previous", "Window", "Strike", "Right", 
                "HighPivot", "LowPivot", "PivotType", "high_pivot", "low_pivot", "pivot_type",
                "Style", "Expiry", "UseMirrorContract", "GetEnumerator", "moving_average_type", "is_ready", "warmup_period",
                "name", "period", "samples", "current", "consolidators", "previous", "window", "int", "strike",
                "right", "style", "expiry", "use_mirror_contract", "warm_up_period", "item", "get_enumerator"]

def _extract_properties(properties: list):
    def select(x):
        name = x["property-name"]
        if name in PROPERTIES_EXCEPTIONS:
            return False
        full_type = x['property-full-type-name']
        # Some properties are lists we cannot plot
        if full_type.startswith('System.Collection'):
            return False
        return full_type.startswith('QuantConnect')
    # Special case for true_range property
    return [x["property-name"].replace('True_range', 'true_range') 
        for x in properties if select(x)]

def split_string(s):
    result = []
    current = []
    bracket_stack = []

    i = 0
    while i < len(s):
        char = s[i]

        if char in '([{':
            bracket_stack.append(char)  # Open a new bracket
            current.append(char)
        elif char in ')]}':
            if bracket_stack:
                bracket_stack.pop()  # Close the last opened bracket
            current.append(char)
        elif char == ',':
            if not bracket_stack:  # Only split if we're not inside any brackets
                result.append(''.join(current).strip())
                current = []  # Reset current for the next segment
            else:
                current.append(char)  # Keep the comma inside the brackets
        else:
            current.append(char)  # Regular character

        i += 1

    # Add the last segment if there's any content
    if current:
        result.append(''.join(current).strip())
    
    return result

def _get_helpers():
    
    methods = get_type(f"QuantConnect.Algorithm.QCAlgorithm", 'csharp')['methods']
    def is_bar(method):
        name, return_type = method["method-name"], method["method-return-type-short-name"]
        arguments = method["method-arguments"]
        selectors = [arg for arg in arguments if arg["argument-name"] == 'selector']
        universe = arguments[0]['argument-type-short-name'] == 'List<Symbol>'
        if not selectors:
            return return_type, (name, False, universe)
        selector_type = selectors[0]['argument-type-short-name']
        return return_type, (name, 'decimal' not in selector_type.lower(), universe)

    tag = "method-return-type-full-name"
    indicators = dict(sorted(set([is_bar(m) for m in methods 
        if m[tag] and m[tag].startswith('QuantConnect.Indicators.')])))
    indicators['IntradayVwap'] = ('VWAP', True, False)  # Manually add IntradayVWAP

    with open(f'Resources/indicators/IndicatorImageGenerator.py', mode='r') as fp:
        lines = fp.readlines()
        helpers = {}
        for i, line in enumerate(lines):
            if 'IndicatorInfo(' in line and ':' in line:
                j = 0
                store_lines = []
                while lines[i+j].strip() != "),":
                    store_lines.append(lines[i+j].strip())
                    j += 1
                    if lines[i+j].strip() in ["),", ')']:
                        break
                indicator_infos = split_string(''.join(store_lines).split("IndicatorInfo(")[1])
                ctor_py = indicator_infos[0].strip()
                key = ctor_py[:ctor_py.find('(')]
                if 'IndicatorExtensions' in ctor_py:
                    key = ctor_py.split(',')[0][23:]
                    key = key[:key.find('(')]
                ctor_cs = indicator_infos[1].strip()[1:-1]
                if not ctor_cs.endswith(')'):
                    ctor_cs = ctor_cs + ')'
                _, is_bar, is_universe = indicators.pop(key)
                helpers[key] = {
                    'ctor-python': ctor_py,
                    'ctor-csharp': ctor_cs,
                    'helper-python': indicator_infos[3].strip()[1:-1],
                    'helper-csharp': indicator_infos[2].strip()[1:-1],
                    'update-python': 'bar' if is_bar else 'bar.end_time, bar.close',
                    'update-csharp': 'bar' if is_bar else 'bar.EndTime, bar.Close',
                    'is-universe': is_universe
                }

        return dict(sorted(helpers.items())), indicators

class IndicatorProcessor:
    def __init__(self, i, _type, info={}):
        key = ' '.join(findall('[a-zA-Z][^A-Z]*', _type))
        for start in  ['De', 'Mc']:
            if key.startswith(f"{start} "):
                key = f'{start}{key[3:]}' 
        print(f'Processing {key}...')
        info.update(self._get_type_info(_type))
        self._info = info
   
        self._path = Path(self._get_path(i, key))
        self._path.mkdir(parents=True, exist_ok=True)

        image = '/'.join([part[3:].strip().lower().replace(' ','-') for part in self._path.parts])
        image = f'https://cdn.quantconnect.com/docs/i/{image}.png'

        self._method_csharp = info['helper-csharp'][:info['helper-csharp'].find('(')] \
            if 'helper-csharp' in info else _type
        self._method_python = info['helper-python'][:info['helper-python'].find('(')][5:] \
            if 'helper-python' in info else key.lower().replace(' ','_')

        description = _format_introduction(_type, info['description']) \
            if 'description' in info else \
            f"Create a new {key} candlestick pattern to indicate the pattern's presence."
        
        with open(self._path / "01 Introduction.html", 'w', encoding='utf-8') as f:
            f.write(self._get_introduction(description))

        self._generate_visualization_section(image)
        self._generate_metadata(key, description, image)

    def _method_class(self):
        return 'QCAlgorithm'

    def _get_introduction(self, description):
        type_ = self._info["type-name"]
        return f"""{TAG}
<p>{description}</p>
<p>To view the implementation of this indicator, see the <a rel="nofollow" target="_blank" href="https://github.com/QuantConnect/Lean/tree/master/Indicators/{type_}.cs">LEAN GitHub repository</a>.</p>"""

    def _get_links(self):
        return [
            f'{CS_REFERENCE}Algorithm_1_1QCAlgorithm.html',
            f'{PY_REFERENCE}Algorithm/QCAlgorithm/#QuantConnect.Algorithm.QCAlgorithm.{self._method_python}',
            f'{CS_REFERENCE}Indicators_1_1{self._info["type-name"]}.html',
            f'{PY_REFERENCE}Indicators/{self._info["type-name"]}',
        ]

    def _get_path(self, i, key):
        return f'{INDICATORS}/{1+i:03} {key}'

    def _get_type_info(self, type_):
        return get_type(f"QuantConnect.Indicators.{type_}", 'python')

    def _generate_visualization_section(self, src):
        with open(self._path / "03 Visualization.html", mode='w', encoding='utf-8') as f:
            f.write(f"""{TAG}
<p>The following plot shows values for some of the <code>{self._info["type-name"]}</code> indicator properties:</p>
<img class='docs-image' style="width: 100%" alt='{self._info["type-name"]} line plot.' src='{src}'>""")

    def _generate_metadata(self, key, description, image):
        if description.find('<see cref=\"T:') > 0:
            description = description.replace('<see cref=\"T:','').replace('\" />','')
        description = sub(r'<a href=".*?">(.*?)</a>', r'\1', description)
        description = sub(r'<sup>(.*?)</sup>', "", description)
        if len(description) > 127:
            description = description[:127] + '...'
        with open(self._path / "metadata.json", mode='w', encoding='utf-8') as f:
            f.write(dumps({
                'type': 'metadata',
                'values': {
                    'description': description,
                    'keywords': key.lower(),
                    'og:type': 'website',
                    'og:description': description,
                    'og:title': f'{key} - Using Indicators on QuantConnect.com',
                    'og:site_name': f'{key} - Using Indicators on QuantConnect.com',
                    'og:image': image
                }
            }, indent=4))

    def _process_properties(self):
        self._info[f'properties-python'] = _extract_properties(self._info['properties'])
        csharp_type = get_type(f"QuantConnect.Indicators.{self._info['type-name']}", 'csharp')
        self._info[f'properties-csharp'] = _extract_properties(csharp_type['properties'])

    def run(self):
        links = self._get_links()
        self._process_properties()

        universe_code = '' if not self._info.get('is-universe', False) else f'''
<p>To create an automatic indicator for <code>{self._info["type-name"]}</code> using universe constituents, call the <code class='csharp'>{self._method_csharp}</code><code class='python'>{self._method_python}</code> helper method from the <code>QCAlgorithm</code> class. The <code class='csharp'>{self._method_csharp}</code><code class='python'>{self._method_python}</code> method creates a <code>{self._info["type-name"]}</code> object, hooks it up for automatic updates, and returns it so you can used it in your algorithm. In this case, you should call the helper method in the <code class="csharp">OnSecuritiesChanged</code><code class="python">on_securities_changed</code> method.<p>
<div class="section-example-container testable">
<pre class="csharp">{self._get_csharp_universe_code()}</pre>
<pre class="python">{self._get_python_universe_code()}</pre></div>'''

        with open(self._path / f"02 Using {self._method_csharp} Indicator.html", mode='w') as f:
            f.write(f'''<p>To create an automatic indicator for <code>{self._info["type-name"]}</code>, call the <code class='csharp'>{self._method_csharp}</code><code class='python'>{self._method_python}</code> helper method from the <code>QCAlgorithm</code> class. The <code class='csharp'>{self._method_csharp}</code><code class='python'>{self._method_python}</code> method creates a <code>{self._info["type-name"]}</code> object, hooks it up for automatic updates, and returns it so you can used it in your algorithm. In most cases, you should call the helper method in the <code class="csharp">Initialize</code><code class="python">initialize</code> method.<p>
<div class="section-example-container testable">
<pre class="csharp">{self._get_csharp_code()}</pre>
<pre class="python">{self._get_python_code()}</pre></div>{universe_code}
<p>For more information about this method, see the <a rel="nofollow" target="_blank" class='csharp' href="{links[0]}">{self._method_class()} class</a><a rel="nofollow" target="_blank" class='python' href="{links[1]}">{self._method_class()} class</a>.</p>
<p>You can manually create a <code>{self._info["type-name"]}</code> indicator, so it doesn't automatically update. Manual indicators let you update their values with any data you choose.</p>
<p>Updating your indicator manually enables you to control when the indicator is updated and what data you use to update it. To manually update the indicator, call the <code class="csharp">Update</code><code class="python">update</code> method. The indicator will only be ready after you prime it with enough data.</p>
<div class="section-example-container testable">
<pre class="csharp">{self._get_csharp_code("ctor")}</pre>
<pre class="python">{self._get_python_code("ctor")}</pre></div>
<p>For more information about this indicator, see its <a rel="nofollow" target="_blank" class='csharp' href="{links[2]}">reference</a><a rel="nofollow" target="_blank" class='python' href="{links[3]}">reference</a>.</p>''')

        with open(self._path / "04 Indicator History.html", mode='w', encoding='utf-8') as f:
            f.write(f'''<p>To get the historical data of the <code>{self._info["type-name"]}</code> indicator, call the <code class="csharp">IndicatorHistory</code><code class="python">self.indicator_history</code> method. This method resets your indicator, makes a <a href='/docs/v2/writing-algorithms/historical-data/history-requests'>history request</a>, and updates the indicator with the historical data. Just like with regular history requests, the <code class="csharp">IndicatorHistory</code><code class="python">indicator_history</code> method supports time periods based on a trailing number of bars, a trailing period of time, or a defined period of time. If you don't provide a <code>resolution</code> argument, it defaults to match the resolution of the security subscription.
</p>
<div class="section-example-container testable">
<pre class="csharp">{self._get_csharp_history()}</pre>
<pre class="python">{self._get_python_history()}</pre></div>''')

    def _get_csharp_initialize(self, method_type):
        type_name = self._info["type-name"]
        method_call = self._info[f'{method_type}-csharp']
        has_reference = 'reference' in method_call
        add_subscription = f'''_symbol = AddEquity("SPY", Resolution.Daily).Symbol;'''
        if has_reference:
            add_subscription = f'''_symbol = AddEquity("QQQ", Resolution.Daily).Symbol;
        _reference = AddEquity("SPY", Resolution.Daily).Symbol;'''
        if type_name == 'IntradayVwap':
            add_subscription = add_subscription.replace('Daily', 'Minute')
        helper = method_call[:method_call.find('(')]
        if method_type == 'ctor': method_call = 'new ' + method_call
        variable = helper.lower()
        code=f"""public class {type_name}Algorithm : QCAlgorithm
&lcub;
    private Symbol _symbol{',_reference' if has_reference else ''};
    private {type_name} _{variable};

    public override void Initialize()
    &lcub;
        {add_subscription}
        _{variable} = {method_call};"""
        return code, type_name, variable, has_reference

    def _get_csharp_code_internal(self, method_type, code, type_name, variable, has_reference):
        properties = self._info["properties-csharp"]
        code += """
    &rcub;

    public override void OnData(Slice data)
    &lcub;"""
        if method_type == 'ctor':
            update_arg = self._info['update-csharp']
            code += f"""
        if (data.Bars.TryGetValue(_symbol, out var bar))
            _{variable}.Update({update_arg});"""
            if has_reference:
                code += f"""
        if (data.Bars.TryGetValue(_reference, out var bar))
            _{variable}.Update({update_arg});"""
        code += f"""

        if (_{variable}.IsReady)
        &lcub;
            // The current value of _{variable} is represented by itself (_{variable})
            // or _{variable}.Current.Value
            Plot("{type_name}", "{variable}", _{variable});"""
        if properties:
            code += """
            // Plot all properties of abands"""
            for property in properties:
                code += f"""
            Plot("{type_name}", "{property.lower()}", _{variable}.{property});"""
        return (code + """
        &rcub;
    &rcub;
&rcub;""").replace('&lcub;', '{').replace('&rcub;', '}')

    def _get_csharp_code(self, method_type="helper"):
        code, type_name, variable, has_reference = self._get_csharp_initialize(method_type)
        return self._get_csharp_code_internal(method_type, code, type_name, variable, has_reference)

    def _get_csharp_history(self):
        code, _, variable, has_reference = self._get_csharp_initialize('helper')
        properties = self._info["properties-csharp"]
        symbols = 'new[] { _symbol, _reference }' if has_reference else '_symbol'
        code += f"""

        var indicatorHistory = IndicatorHistory(_{variable}, {symbols}, 100, Resolution.Minute);
        var timeSpanIndicatorHistory = IndicatorHistory(_{variable}, {symbols}, TimeSpan.FromDays(10), Resolution.Minute);
        var timePeriodIndicatorHistory = IndicatorHistory(_{variable}, {symbols}, new DateTime(2024, 7, 1), new DateTime(2024, 7, 5), Resolution.Minute);"""
        if properties:
            code += f"""

        // Access all attributes of indicatorHistory"""
            for property in properties:
                property_var = property.lower() if property.isupper() else property[0].lower()+property[1:]
                code += f"""
        var {property_var} = indicatorHistory.Select(x => ((dynamic)x).{property}).ToList();"""
        return (code + """
    &rcub;
&rcub;""").replace('&lcub;', '{').replace('&rcub;', '}')

    def _get_csharp_universe_code(self, method_type='helper'):
        type_name = self._info["type-name"]
        method_call = self._info[f'{method_type}-csharp']
        has_reference = 'reference' in method_call
        helper = method_call[:method_call.find('(')]
        variable = helper.lower()
        code=f"""public class {type_name}Algorithm : QCAlgorithm
&lcub;
    private Universe _universe;
    private {type_name} _{variable};

    public override void Initialize()
    &lcub;
        UniverseSettings.Resolution = Resolution.Daily;
        UniverseSettings.Schedule.On(DateRules.MonthStart());
        _universe = AddUniverse(Universe.ETF("SPY"));
    &rcub;

    public override void OnSecuritiesChanged(SecurityChanges changes)
    &lcub;
        _{variable} = {helper}(_universe.Selected);"""
        return self._get_csharp_code_internal('helper', code, type_name, variable, False)

    def _get_python_initialize(self, method_type):
        type_name = self._info['type-name']
        method_call = self._info[f'{method_type}-python']
        has_reference = 'reference' in method_call
        add_subscription = '''self._symbol = self.add_equity("SPY", Resolution.DAILY).symbol'''
        if has_reference:
            add_subscription = '''self._symbol = self.add_equity("QQQ", Resolution.DAILY).symbol
        self._reference = self.add_equity("SPY", Resolution.DAILY).symbol'''
        if type_name == 'IntradayVwap':
            add_subscription = add_subscription.replace('DAILY', 'MINUTE')
        variable = method_call[:method_call.find('(')].replace('self.','').lower()
        if method_call.startswith('IndicatorExtensions'):
            variable = type_name.lower()
        code = f"""class {type_name}Algorithm(QCAlgorithm):
    def initialize(self) -> None:
        {add_subscription}
        self._{variable} = {method_call}"""
        return code, type_name, variable, has_reference

    def _get_python_code_internal(self, method_type, code, type_name, variable, has_reference):
        properties = self._info["properties-python"]
        code += f"""

    def on_data(self, slice: Slice) -> None:"""
        if method_type == 'ctor':
            update_arg = self._info['update-python']
            code += f"""
        bar = slice.bars.get(self._symbol)
        if bar:
            self._{variable}.update({update_arg})"""
            if has_reference:
                code += f"""
        bar = slice.bars.get(self._reference)
        if bar:
            self._{variable}.update({update_arg})"""
        code += f"""

        if self._{variable}.is_ready:
            # The current value of self._{variable} is represented by self._{variable}.current.value
            self.plot("{type_name}", "{variable}", self._{variable}.current.value)"""
        if properties:
            code += f"""
            # Plot all attributes of self._{variable}"""
            for property in properties:
                code += f"""
            self.plot("{type_name}", "{property.lower()}", self._{variable}.{property}.current.value)"""
        return code

    def _get_python_code(self, method_type="helper"):
        code, type_name, variable, has_reference = self._get_python_initialize(method_type)
        return self._get_python_code_internal(method_type, code, type_name, variable, has_reference)
        
    def _get_python_history(self):
        code, _, variable, has_reference = self._get_python_initialize('helper')
        properties = self._info["properties-python"]
        symbols = '[ self._symbol, self._reference ]' if has_reference else 'self._symbol'
        code += f"""

        indicator_history = self.indicator_history(self._{variable}, {symbols}, 100, Resolution.MINUTE)
        timedelta_indicator_history = self.indicator_history(self._{variable}, {symbols}, timedelta(days=10), Resolution.MINUTE)
        time_period_indicator_history = self.indicator_history(self._{variable}, {symbols}, datetime(2024, 7, 1), datetime(2024, 7, 5), Resolution.MINUTE)
    """
        if properties:
            code += f"""
        # Access all attributes of indicator_history
        indicator_history_df = indicator_history.data_frame"""
            for property in properties:
                code += f"""
        {property} = indicator_history_df["{property.replace('_','')}"]"""
        return code

    def _get_python_universe_code(self, method_type='helper'):
        type_name = self._info['type-name']
        method_call = self._info[f'{method_type}-python']
        variable = method_call[:method_call.find('(')].replace('self.','').lower()
        code = f"""class {type_name}Algorithm(QCAlgorithm):
    def initialize(self) -> None:
        self.universe_settings.resolution = Resolution.DAILY
        self.universe_settings.schedule.on(self.date_rules.month_start())
        self._universe = self.add_universe(self.universe.etf('SPY'))

    def on_securities_changed(self, changes: SecurityChanges) -> None:
        self._{variable} = self.{variable}(list(self._universe.selected))"""
        return self._get_python_code_internal('helper', code, type_name, variable, False)

class OptionIndicatorProcessor(IndicatorProcessor):
    def _process_properties(self):
        pass
    
    def _get_csharp_initialize(self, method_type):
        type_name = self._info["type-name"]
        method_call = self._info[f'{method_type}-csharp']
        helper = method_call[:method_call.find('(')]
        if method_type == 'ctor': method_call = 'new ' + method_call
        variable = helper.lower()
        code = f"""public class {type_name}Algorithm : QCAlgorithm
&lcub;
    private Symbol _symbol, _option, _mirrorOption;
    private {type_name} _{variable};

    public override void Initialize()
    &lcub;
        SetStartDate(2024, 9, 1);
        SetEndDate(2024, 9, 20);

        _symbol = AddEquity("SPY", Resolution.Daily).Symbol;"""
        if method_type == 'ctor':
            code += f"""
        var interestRateModel = new InterestRateProvider();
        var dividendYieldModel = new DividendYieldProvider(_symbol);
        """
        code += f"""
        _option = SymbolRepresentation.ParseOptionTickerOSI("SPY 240920C00564000");
        _mirrorOption = SymbolRepresentation.ParseOptionTickerOSI("SPY 240920P00564000");
        AddOptionContract(_option, Resolution.Daily);
        AddOptionContract(_mirrorOption, Resolution.Daily);

        _{variable} = {method_call};"""
        return code, type_name, variable

    def _get_csharp_code(self, method_type='helper'):
        code, type_name, variable = self._get_csharp_initialize(method_type)
        code += """
    &rcub;

    public override void OnData(Slice data)
    &lcub;"""
        if method_type == 'ctor':
            code += f"""
        if (data.Bars.TryGetValue(_symbol, out var bar))
            _{variable}.Update(new IndicatorDataPoint(_symbol, bar.EndTime, bar.Close));
        if (data.QuoteBars.TryGetValue(_option, out var quoteBar))
            _{variable}.Update(new IndicatorDataPoint(_option, quoteBar.EndTime, quoteBar.Close));
        if (data.QuoteBars.TryGetValue(_mirrorOption, out quoteBar))
            _{variable}.Update(new IndicatorDataPoint(_mirrorOption, quoteBar.EndTime, quoteBar.Close));
"""
        return (code + f"""
        if (_{variable}.IsReady)
        &lcub;
            // The current value of _{variable} is represented by itself (_{variable})
            // or _{variable}.Current.Value
            Plot("{type_name}", "{variable}", _{variable});
        &rcub;
    &rcub;
&rcub;""").replace('&lcub;', '{').replace('&rcub;', '}')

    def _get_csharp_history(self):
        code, _, variable = self._get_csharp_initialize('helper')
        symbols = 'new[] { _symbol, _option, _mirrorOption }'
        return (code + f"""

        var indicatorHistory = IndicatorHistory(_{variable}, {symbols}, 100, Resolution.Minute);
        var timeSpanIndicatorHistory = IndicatorHistory(_{variable}, {symbols}, TimeSpan.FromDays(10), Resolution.Minute);
        var timePeriodIndicatorHistory = IndicatorHistory(_{variable}, {symbols}, new DateTime(2024, 7, 1), new DateTime(2024, 7, 5), Resolution.Minute);
    &rcub;
&rcub;""").replace('&lcub;', '{').replace('&rcub;', '}')

    def _get_python_initialize(self, method_type):
        type_name = self._info["type-name"]
        method_call = self._info[f'{method_type}-python']
        variable = method_call[:method_call.find('(')].replace('self.','').lower()
        code = f"""class {type_name}Algorithm(QCAlgorithm):
    def initialize(self) -> None:
        self.set_start_date(2024, 9, 1)
        self.set_end_date(2024, 9, 20)

        self._symbol = self.add_equity("SPY", Resolution.DAILY).symbol"""
        if method_type == "ctor":
            code += """
        interest_rate_model = InterestRateProvider()
        dividend_yield_model = DividendYieldProvider(self._symbol)
"""
        code += f"""
        self._option = SymbolRepresentation.parse_option_ticker_osi("SPY 240920C00564000");
        self._mirror_option = SymbolRepresentation.parse_option_ticker_osi("SPY 240920P00564000");
        self.add_option_contract(self._option, Resolution.DAILY);
        self.add_option_contract(self._mirror_option, Resolution.DAILY);

        self._{variable} = {method_call}
"""
        return code, type_name, variable

    def _get_python_code(self, method_type='helper'):
        code, type_name, variable = self._get_python_initialize(method_type)
        code += f"""
    def on_data(self, slice: Slice) -> None:"""
        if method_type == "ctor":
            code += f"""
        bar = slice.bars.get(self._symbol)
        if bar:
            self._{variable}.update(IndicatorDataPoint(self._symbol, bar.end_time, bar.close))
        bar = slice.quote_bars.get(self._option)
        if bar:
            self._{variable}.update(IndicatorDataPoint(self._option, bar.end_time, bar.close))
        bar = slice.quote_bars.get(self._mirror_option)
        if bar:
            self._{variable}.update(IndicatorDataPoint(self._mirror_option, bar.end_time, bar.close))
"""
        return code + f"""
        if self._{variable}.is_ready:
            # The current value of self._{variable} is represented by self._{variable}.current.value
            self.plot("{type_name}", "{variable}", self._{variable}.current.value)"""

    def _get_python_history(self):
        code, _, variable = self._get_python_initialize('helper')
        symbols = '[self._symbol, self._option, self._mirror_option]'
        return code + f"""
        indicator_history = self.indicator_history(self._{variable}, {symbols}, 100, Resolution.MINUTE)
        timedelta_indicator_history = self.indicator_history(self._{variable}, {symbols}, timedelta(days=10), Resolution.MINUTE)
        time_period_indicator_history = self.indicator_history(self._{variable}, {symbols}, datetime(2024, 7, 1), datetime(2024, 7, 5), Resolution.MINUTE)"""

class CandlestickProcessor(IndicatorProcessor):
    def _method_class(self):
        return 'CandlestickPatterns'
    
    def _generate_visualization_section(self, src):
        pass
    
    def _get_links(self):
        return [
            f'{CS_REFERENCE}Algorithm_1_1CandlestickPatterns.html',
            f'{PY_REFERENCE}Algorithm/CandlestickPatterns/#QuantConnect.Algorithm.CandlestickPatterns.{self._method_python}',
            f'{CS_REFERENCE}Indicators_1_1CandlestickPatterns_1_1{self._info["type-name"]}.html',
            f'{PY_REFERENCE}Indicators/CandlestickPatterns/{self._info["type-name"]}',
        ]
    def _get_path(self, i, key):
        return f'{INDICATORS}//00 Candlestick Patterns//{1+i:02} {key}'

    def _get_type_info(self, type_):
        return {'type-name': type_}

    def _process_properties(self):
        pass

    def _get_introduction(self, description):
        return f"""{TAG}
<p>{description}</p>
<p>To view the implementation of this candlestick pattern, see the <a rel="nofollow" target="_blank" href="https://github.com/QuantConnect/Lean/tree/master/Indicators/CandlestickPatterns/{self._info["type-name"]}.cs">LEAN GitHub repository</a>.</p>"""

    def _get_csharp_initialize(self, method_type):
        type_name = self._info["type-name"]
        method_call = f'new {type_name}()' if method_type == "ctor" else \
            f'CandlestickPatterns.{type_name}(_symbol)'
        variable = type_name[0].lower() + type_name[1:]
        code=f"""public class {type_name}Algorithm : QCAlgorithm
&lcub;
    private Symbol _symbol;
    private {type_name} _{variable};

    public override void Initialize()
    &lcub;
        _symbol = AddEquity("SPY", Resolution.Daily).Symbol;
        _{variable} = {method_call};"""
        return code, type_name, variable

    def _get_csharp_code(self, method_type='helper'):
        code, type_name, variable = self._get_csharp_initialize(method_type)
        code += """
    &rcub;

    public override void OnData(Slice data)
    &lcub;"""
        if method_type == "ctor":
            code += f"""
        if (data.Bars.TryGetValue(_symbol, out var bar))
            _{variable}.Update(bar);
"""
        return (code + f"""
        if (_{variable}.IsReady)
        &lcub;
            // The current value of _{variable} is represented by itself (_{variable})
            // or _{variable}.Current.Value
            Plot("{type_name}", "{variable}", _{variable});
        &rcub;
    &rcub;
&rcub;""").replace('&lcub;', '{').replace('&rcub;', '}')

    def _get_csharp_history(self):
        code, _, variable = self._get_csharp_initialize('helper')
        return (code + f"""

        var indicatorHistory = IndicatorHistory(_{variable}, _symbol, 100, Resolution.Minute);
        var timeSpanIndicatorHistory = IndicatorHistory(_{variable}, _symbol, TimeSpan.FromDays(10), Resolution.Minute);
        var timePeriodIndicatorHistory = IndicatorHistory(_{variable}, _symbol, new DateTime(2024, 7, 1), new DateTime(2024, 7, 5), Resolution.Minute);
    &rcub;
&rcub;""").replace('&lcub;', '{').replace('&rcub;', '}')

    def _get_python_initialize(self, method_type):
        type_name = self._info["type-name"]
        variable = '_'.join(findall('[a-zA-Z][^A-Z]*', type_name)).lower()
        method_call = f'{type_name}()' if method_type == "ctor" else \
        f'self.candlestick_patterns.{variable}(self._symbol)'
        code = f"""class {type_name}Algorithm(QCAlgorithm):
    def initialize(self) -> None:
        self._symbol = self.add_equity("SPY", Resolution.DAILY).symbol
        self._{variable} = {method_call}
"""
        return code, type_name, variable

    def _get_python_code(self, method_type='helper'):
        code, type_name, variable = self._get_python_initialize(method_type)
        code += """
    def on_data(self, slice: Slice) -> None:"""
        if method_type == "ctor":
            code += f"""
        bar = slice.bars.get(self._symbol)
        if bar:
            self._{variable}.update(bar)
"""
        return code + f"""
        if self._{variable}.is_ready:
            # The current value of self._{variable} is represented by self._{variable}.current.value
            self.plot("{type_name}", "{variable}", self._{variable}.current.value)"""

    def _get_python_history(self):
        code, _, variable = self._get_python_initialize('helper')
        return (code + f"""
        indicator_history = self.indicator_history(self._{variable}, self._symbol, 100, Resolution.MINUTE)
        timedelta_indicator_history = self.indicator_history(self._{variable}, self._symbol, timedelta(days=10), Resolution.MINUTE)
        time_period_indicator_history = self.indicator_history(self._{variable}, self._symbol, datetime(2024, 7, 1), datetime(2024, 7, 5), Resolution.MINUTE)""")

def main():
    helpers, undocumented = _get_helpers()
    for i, (type_, info) in enumerate(helpers.items()):
        if type_ in OPTION_INDICATORS:
            OptionIndicatorProcessor(i, type_, info).run()
        else:
            IndicatorProcessor(i, type_, info).run()

    count = len(helpers)
    with open('Resources/indicators/indicator_count.html', 'w', encoding='utf-8') as fp:
        fp.write(f'There are {count} indicators.')

    generate_landing_page(0, count, INDICATORS, 'Supported Indicators',
        '<p>Indicators translate a stream of data points into a numerical value you can use to detect trading opportunities. LEAN provides more than 100 pre-built technical indicators and candlestick patterns you can use in your algorithms. You can use any of the following indicators. Click one to learn more.</p>')

    candlestick_methods = get_type(f"QuantConnect.Algorithm.CandlestickPatterns", 'csharp')['methods']
    for i, type_ in enumerate(sorted([x['method-name'] for x in candlestick_methods])):
        CandlestickProcessor(i, type_).run()

    candles = len(candlestick_methods)
    with open('Resources/indicators/candlestick_pattern_count.html', 'w', encoding='utf-8') as fp:
        fp.write(f'There are {candles} candlestick pattern indicators.')

    generate_landing_page(1, 1+candles, f'{INDICATORS}/00 Candlestick Patterns', 'Candlestick Patterns',
        '<p>You can use any of the following candlestick patterns. Click one to learn more.</p>')

    if undocumented:
        print('Undocumented indicators:' + ', '.join([f'{k}: {v[0]}' for k,v in undocumented.items()]))
    return len(undocumented)

if __name__ == "__main__":
    # DELETE ALL FILES
    rmtree(INDICATORS, ignore_errors=True)
    exit(main())